## 限流

常见的限流有

+ 限制总并发数（数据库连接池、线程池）
+ 限制瞬时并发数（Nginx的limit_conn模块）
+ 限制时间窗口内的平均速率（Guava的RateLimiter、Nginx的limit_req模块）
+ 限制远程接口调用速率
+ 限制MQ的消费速率

### 限流算法

#### 令牌桶算法

存放固定容量令牌的桶，按照固定速率往桶里添加令牌。算法描述如下：

+ 假设限制2r/s，则按照500毫秒的固定速率往桶中添加令牌
+ 桶中最多存放b个令牌，当桶满时，新添加的令牌被丢弃或拒绝
+ 当一个n个字节大小的数据包到达，将从桶中删除n个令牌，接着数据包被发送到网络上
+ 如果桶中的令牌不足n个，则不会删除令牌，且该数据包将被限流（要么丢弃、要么在缓冲区等待）


#### 漏桶算法

描述如下：

+ 一个固定容量的漏桶，按照常量固定速率流出水滴。
+ 如果桶是空的，则不需流出水滴
+ 可以以任意速率流入水滴到漏桶
+ 如果流入水滴超出了桶的容量，则流入的水滴溢出了，而漏桶容量是不变的

#### 漏桶算法 VS 令牌桶算法


+ 令牌桶是按照固定速率往桶中添加令牌，请求是否被处理需要看桶中令牌是否足够，当令牌数减为零时，则拒绝新的请求。
+ 漏桶则是按照常量固定速率流出请求，流入请求速率任意，当流入的请求数累积到漏桶容量时，则新的流入请求则被拒绝。

#### 限流某个接口的总并发数/请求数

如果接口可能有突发访问情况，但又担心访问量太大造成崩溃，如抢购业务，那么这个时候就需要限制这个接口的总并发/请求数总数了。因为粒度比较细，可以为每个接口都设置相应的阈值。可以使用Java的AtomicLong或者Semaphore进行限流。

```java

try {

    if (atomic.incrementAndGet() > 限流数) {
    
        // 拒绝请求
    
    }

    // 处理请求
} finally {

    atomic.decrementAndGet();

}

```
