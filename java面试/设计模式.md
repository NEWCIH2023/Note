

#### 创建型

+ `单例模式 Singleton`：**确保一个类只有一个实例，并提供该实例的全局访问点**

使用一个私有构造方法、一个私有静态变量以及一个公有静态方法来实现。私有构造方法确保了不能通过构造方法来创建对象实例，只能通过公有静态方法返回唯一的私有静态变量。

> `懒汉式-线程不安全`：私有静态变量被延迟实例化，在多线程环境下不安全，可能多次实例化

```java

public class Singleton {

    private static Singleton uniqueInstance;

    private Singleton() {}

    public static Singleton getUniqueInstance() {
        if (uniqueInstance == null) {
            uniqueInstance = new Singleton();
        }
        return uniqueInstance;
    }

}    

```

> `饿汉式-线程安全`：采取直接实例化的方式就不会产生线程不安全的问题

```java

private static Singleton uniqueInstance = new Singleton();

```

> `懒汉式-线程安全`：只需要对`getUniqueInstance()`方法加锁，那么在一个时间点只能有一个线程能够进入该方法，从而避免了实例化多次`uniqueInstance`。但是当一个线程进入后其他线程必须等待，即使对象已经被实例化，这会让阻塞时间过长，因此该方法有性能问题。

```java

public static synchronized Singleton getUniqueInstance() {

    if (uniqueInstance == null) {
        uniqueInstance = new Singleton();
    }
    return uniqueInstance;
}

```

> `双重校验锁-线程安全`：对象只需要被实例化一次，之后就可以直接使用了。加锁操作只需要对实例化部分的代码进行，只有当`uniqueInstance`没有被实例化时，才需要进行加锁。`双重校验锁`先判断`uniqueInstance`是否已经被实例化，如果没有被实例化，那么才对实例化语句进行加锁。

```java

public static getUniqueInstance() {
    if (null == uniqueInstance) {
        synchronized(Singleton.class) {
            if (null == uniqueInstance) {
                uniqueInstance = new Singleton();
            }
        }
    }
}

```

`uniqueInstance`采用`volatile`关键字修饰也是很有必要的，`uniqueInstance = new Singleton();`这段代码其实是分三步执行

1. 为`uniqueInstance`分配内存空间
2. 初始化`uniqueInstance`
3. 将`uniqueInstance`指向分配的内存地址

> ‼️ 由于`JVM`具有`指令重排`的特性，执行顺序有可能变成`1>3>2`。`指令重排`在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程`T1`执行了`1`和`3`，此时`T2`调用`getUniqueInstance()`后发现`uniqueInstance`不为空，因此返回`uniqueInstance`，但此时`uniqueInstance`还未被初始化。

**使用volatile可以禁止JVM的指令重排，保证在多线程环境下也能正常运行**

> `静态内部类实现`：当`Singleton`类被加载时，静态内部类`SingletonHolder`没有被加载进内存。只有当调用`getUniqueInstance()`方法从而触发`SingletonHolder`.`INSTANCE`时`SingletonHolder`才会被加载，此时初始化`INSTANCE`实例，并且`JVM`能确保`INSTANCE`只被实例化一次。

```java
public class Singleton() {
    private Singleton(){}

    private static class SingletonHolder() {
        private static final Singleton INSTANCE = new Singleton();
    }

    public static Singleton getUniqueInstance() {
        return SingletonHolder.INSTNACE;
    }
}
```

> `枚举实现`：可以防止反射攻击。在其他实现中，通过`setAccessible()`方法可以将私有构造方法的访问级别设置为`public`，然后调用构造方法从而实例化对象，如果要防止这种攻击，需要在构造方法中添加防止多次实例化的代码。该实现是由`JVM`保证之后实例化一次，因此不会出现上述的反射攻击。该实现在多次`序列化`和`反序列化`之后，不会得到多个实例。而其他实现需要使用`transient`修饰所有字段，并且实现`序列化`和`反序列化`的方法。

```java
public enum Singleton {

    INSTANCE;

    private String objName;

    public String getObjName(){
        return objName;
    }

    public void setObjName(String objName) {
        this.objName = objName;
    }
}

```

+ `简单工厂` `Simple Factory`：**在创建一个对象时不向客户暴露内部细节，并提供一个创建对象的通用接口**

> 简单工厂把实例化的操作单独放到一个类，这个类就成为`简单工厂类`，让`简单工厂类`来决定应该用哪个具体子类来实例化。这样做能把客户类和具体子类的实现解耦，客户类不再需要知道有哪些子类以及应当实例化哪个子类。客户类往往有多个，如果不使用简单工厂，那么所有的客户类都要知道所有子类的细节。而且一旦子类发生改变，例如增加子类，那么所有的客户类都要进行修改。


```java
public class SimpleFactory {
    public Product createProduct(int type) {
        if (type == 1)
            return new ConcreateProduct1();
        else if (type == 2) 
            return new ConcreateProduct2();
        return new ConcreateProduct3();
    }
}

public class Client {
    public static void main(String[] args) {
        SimpleFactory f = new SimpleFactory();
        Product p = f.createProduct(1);
    }
}

```

+ `工厂方法` `Factory Method`：定义了一个创建对象的接口，但由子类决定要实例化哪个类。工厂方法把实例化操作推迟到子类。

> 在简单工厂中，创建对象的是另一个类，而在工厂方法中，是由子类来创建对象。下图中，Factory有一个doSomething方法，这个方法需要用到一个产品对象，这个产品对象由factoryMethod方法创建。该方法是抽象的，需要由子类去实现。

```java
public abstract class Factory {
    abstract public Product factoryMethod();
    public void doSomething(){
        // 
    }
}

public class ConcreateFactory extend Factory {
    public Product factoryMethod() {
        return new ConcreateProduct();
    }
}    

public class ConcreateFactory1 extends Factory {
    public Product factoryMethod() {
        return new ConcreateProduct1();
    }
}

```

+ `抽象工厂` `Abstract Factory`：**提供一个接口，用于创建相关的对象家族**

> 抽象工厂模式创建的是对象家族，也就是很多对象而不是一个对象，并且这些对象是相关的，也就是说必须一起创建出来。而工厂方法模式只是用于创建一个对象，这和抽象工厂模式有很大不同。抽象工厂模式用到了工厂方法模式来创建单一对象，AbstractFactory中的createProductA()和createProductB()方法都是让子类来实现，这两个方法单独来看就是在创建一个对象，这符合工厂方法模式的定义。

至于创建对象的家族这一概念是在Client体现，Client要通过AbstractFactory同时调用两个方法来创建出两个对象，在这里这两个对象就有很大的相关性，Client需要同时创建出这两个对象。从高层次来看，抽象工厂使用了组合，即Client组合了AbstractFactory，而工厂方法模式使用了继承。

```java

public class AbstractProductA {
}

public class AbstractProductB {
}

public class ProductA1 extends AbstractProductA {
}

public class ProductA2 extends AbstractProductA {
}
    
public class ProductB1 extends AbstractProductB {
}

public class ProductB2 extends AbstractProductB {
}

public abstract class AbstractFactory {
    abstract AbstractProductA createProductA();
    abstract AbstractProductB createProductB();
}

public class ConcreteFactory1 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA();
    }
    AbstractProductB createProductB() {
        return new ProductB();
    }
}

public class ConcreteFactory2 extends AbstractFactory {
    AbstractProductA createProductA() {
        return new ProductA();
    }
    AbstractProductB createProductB() {
        return new ProductB();
    }
}

public class Client {
    public static void main(String[] args) {
        AbstractFactory af = new ConcreateFactory1();
        AbstractProductA a = af.createProductA();
        AbstractProductB b = af.createProductB();
    }
}

```

+ `生成器模式` `Builder`：封装一个对象的构造过程，并允许按步骤构造

> 将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

与抽象工厂的区别：在生产者模式里，有个指导者，由指导者来管理生产者，用户是与指导者联系的，指导者联系生产者最后得到产品。即生产者模式可以强制实行一种分步骤进行的建造过程。

![生产者模式UML](https://github.com/CyC2018/CS-Notes/blob/master/notes/pics/db5e376d-0b3e-490e-a43a-3231914b6668.png)


以下是简易的StringBuilder实现，参考了JDK8源码

```java

public class AbstractStringBuilder {

    protected char[] value;
    protected int count;

    public AbstractStringBuilder(int capacity) {
        count = 0;
        value = new char[capacity];
    }

    public AbstractStringBuilder append(char c) {
        ensureCapacityInternal(count + 1);
        value[count++] = c;
        return this;
    }

    private void ensureCapacityInternal(int minimumCapacity) {
        if (minimumCapacity - value.length > 0) {
            expandCapacity(minimumCapacity);
        }
    }

    void expandCapacity(int minimumCapacity) {
        int newCapacity = value.length * 2 + 2;
        if (newCapacity - minimumCapacity < 0) {
            newCapacity = minimumCapacity;
        }
        if (newCapacity < 0) {
            if (minimumCapacity < 0) {
                throw new OutOfMemoryError();
            }
            newCapacity = Integer.MAX_VALUE;
        }
    }
}

public class StringBuilder extends AbstractStringBuilder {
    public StringBuilder() {
        super(16);
    }

    @Override
    public String toString() {
        return new String(value, 0, count);
    }
}

public class Client {
    public static void main(String[] args) {
        StringBuilder sb = new StringBuilder();
        final int count = 20;
        for (int i = 0; i < count; i++) {
            sb.append((char)('a'+i));
        }
        System.out.println(sb.toString());
    }
}

```

+ `原型模式` `Prototype`：**使用原型实例指定要创建对象的类型，通过复制这个原型来创建新的对象**

> 原型模式主要用于对象的复制，它的核心就是类图中的原型类`Prototype`。`Prototype`类需要具备以下两个条件：

+ 实现`Cloneable`接口。在`java`语言有一个`Cloneable`接口，它的作用只有一个，就是在运行时通知虚拟机可以安全地在实现了此接口的类上使用`clone`方法。在`java`虚拟机中，只有实现了这个接口的类才可以被拷贝，否则在运行时会抛出`CloneNotSupportedException`异常。

+ 重写`Object`类的`clone`方法。`java`中，所有类的父类都是`Object`类，`Object`类有一个`clone`方法，作用是返回对象的一个拷贝，但是其作用域`protected`类型的，一般的类无法调用，因此，`Prototype`类需要将`clone`方法的作用域修改为`public`类型。

```java

public abstract class Prototype {
    abstract Prototype myClone();
}

public class ConcretePrototype extends Prototype {
    private String field;

    public ConcretePrototype(String field) {
        this.field = field;
    }

    @Override
    Prototype myClone() {
        return new ConcretePrototype(field);
    }

    @Override
    public String toString() {
        return field;
    }
}

public class Client {
    public static void main(String[] args) {
        Prototype prototype = new ConcretePrototype("abc");
        Prototype clone = prototype.myClone();
        System.out.println(clone.toString());
    }
}

```


#### 行为型

+ `责任链` `Chain Of Responsibility`：**使多个对象都有机会处理请求，从而避免请求的发送者和接收者之间的耦合关系。将这些对象连成一条链，并沿着这条链发送该请求，直到有一个对象处理它为止。**

责任链模式结构的重要核心模块

+ Handler 抽象处理者

定义一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者定义了一个抽象处理者类型的对象作为其对下家的引用。通过该引用，处理者可以连成一条链。

+ ConcreteHandler 具体处理者

抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者，在具体处理者中可以访问链中下一个对象，以便请求的转发。

```java

public abstract class Handler {
    protected Handler successor;

    public Handler(Handler successor) {
        this.successor = successor;
    }

    protected abstract void handleRequest(Request request);
}

public class ConcreteHandler1 extends Handler {
    public ConcreteHandler1(Handler successor) {
        super(successor);
    }

    @Override
    protected void handleRequest(Request request) {
        if (request.getType() == RequestType.TYPE1) {
            System.out.println(request.getName() + " is handle by ConcreteHandler1");
            return;
        }
        if (successor != null) {
            successor.handleRequest(request);
        }
    }
}

public class ConcreteHandler2 extends Handler {
    public ConcreteHandler2(Handler successor) {
        super(successor);
    }

    @Override
    protected void handleRequest(Request request) {
        if (request.getType() == RequestType.TYPE2) {
            System.out.println(request.getName() + " is handle by ConcreteHandler2");
            return;
        }
        if (successor != null) {
            successor.handleRequest(request);
        }
    }
}

public class Request {
    
    private RequestType type;
    private String name;

    public Request(RequestType type, String name) {
        this.type = type;
        this.name = name;
    }

    public RequestType getType() {
        return type;
    }

    public String getName() {
        return name;
    }
}

public enum RequestType {
    TYPE1, TYPE2
}

public class Client {
    public static void main(String[] args) {
        Handler handler1 = new ConcreteHandler1(null);
        Handler handler2 = new ConcreteHandler2(handler1);

        Request request1 = new Request(RequestType.TYPE1, "request1");
        handler2.handleRequest(request1);

        Request request2 = new Request(RequestType.TYPE2, "request2");
        handler2.handleRequest(request2);
    }
}

```

+ `命令` `Command`：**将一个请求封装成一个对象，从而让你使用不同的请求把客户端参数化，对请求排队或者记录请求日志，可以提供命令的撤销和恢复功能**
    + 使用命令来参数化其他对象
    + 将命令放入队列中进行排队
    + 将命令的操作记录到日志中
    + 支持可撤销的操作

下面说一下关键的一些类
1. Command类：是一个抽象类，类中对需要执行的命令进行声明，一般来说要对外公布一个`execute`方法用来执行命令
2. ConcreteCommane类：`Command`类的实现类，对抽象类中声明的方法进行实现
3. Client类：最终的客户端调用类
4. Invoker类：调用者，负责调用命令
5. Receiver类：接收者，负责接收命令并且执行命令

```java

public interface Command {
    void execute();
}

public class LightOnCommand implements Command {
    Light light;

    public LightOnCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute() {
        light.on();
    }
}

public class LightOffCommand implements Command {
    Light light;

    public LightOffCommand(Light light) {
        this.light = light;
    }

    @Override
    public void execute(){
        light.off();
    }
}

public class Light {
    public void on() {
        System.out.println("light is on");
    }
    public void off() {
        System.out.println("light is off");
    }
}

public class Invoker {
    private Command[] onCommands;
    private Command[] offCommands;;
    private final int slotNum = 7;

    public Invoker() {
        this.onCommands = new Command[slotNum];
        this.offCommands = new Command[slotNum];
    }

    public void setOnCommand(Command command, int slot) {
        onCommands[slot] = command;
    }

    public void setOffCommand(Command command, int slot) {
        offCommands[slot] = command;
    }
    public void onButtonWasPushed(int slot) {
        onCommands[slot].execute();
    }
    public void offButtonWasPushed(int slot) {
        offCommands[slot].execute();
    }
}

public class Client {
    public static void main(String[] args) {
        Invoker invoker = new Invoker();
        Light light = new Light();
        Command lightOnCommand = new LightOnCommand(light);
        Command lightOffCommand = new LightOffCommand(light);
        invoker.setOnCommand(lightOnCommand, 0);
        invoker.setOffCommand(lightOffCommand, 0);
        invoker.onButtonWasPushed(0);
        invoker.offButtonWasPushed(0);
    }
}
```

+ `解释器` `Interpreter`：**为语言创建解释器，通常由语言的语法和语法分析来定义**
    + `TerminalExpression`：终结符表达式，每个终结符都需要一个`TerminalExpression`
    + `Context`：上下文，包含解释器之外的一些全局信息

以下是一个规则检验器实现，具有and和or规则，通过规则可以构建一颗解析树，用来检验一个文本是否满足解析树定义的规则。

```java
public abstract class Expression {
    public abstract boolean interpret(String str);
}

public class TerminalExpression extends Expression {
    private String literal = null;

    public TerminalExpression(String str) {
        literal = str;
    }

    public boolean interpret(String str) {
        StringTokenizer st = new StringTokenizer(str);
        while(st.hasMoreTokens) {
            String test = st.nextToken();
            if (test.equals(literal)){
                return true;
            }
        }
        return false;
    }
}

public class AndExpression extends Expression {
    private Expression expression1 = null;
    private Expression expression2 = null;

    public AndExpression(Expression expression1, Expression expression2) {
        this.expression1 = expression1;
        this.expression2 = expression2;
    }

    public boolean interpret(String str){
        return expression1.interpret(str) && expression2.interpret(str);
    }
}

public class OnExpression extends Expression {
    private Expression expression1 = null;
    private Expression expression2 = null;

    public OrExpression(Expression expression1, Expression expression2) {
        this.expression1 = expression1;
        this.expression2 = expression2;
    }

    public boolean interpret(String str) {
        return expression1.interpret(str) || expression2.interpret(str);
    }
}

public class Client {
    
    public static Expression buildInterpreterTree() {
        Expression e1 = new TerminalExpression("A");
        Expression e2 = new TerminalExpression("B");
        Expression e3 = new TerminalExpression("C");
        Expression e4 = new TerminalExpression("D");

        Expression a1 = new OrExpression(e2, e3);
        Expression a2 = new OrExpression(e1, a1);

        return new AndExpression(e4, a2);

    }
}

```

+ `迭代器` `Iterator`：提供一种顺序访问聚合对象元素的方法，并且不暴露聚合对象的内部表示。
    + `Aggregate` 是聚合类，其中`createIterator()`方法可以产生一个`Iterator`
    + `Iterator` 主要定义了`hasNext()`和`next()`方法
    + `Client` 组合了`Aggregate`，为了迭代遍历`Aggregate`，也需要组合`Iterator`

```java

public iterface Aggregate {
    Iterator createIterator();
}

public class ConcreteAggregate implements Aggregate {
    private Integer[] items;

    public ConcreteAggregate() {
        items = new Integer[10];
        for (int i = 0; i < items.length; i++) {
            items[i] = i;
        }
    }

    @Override
    public Iterator createIterator() {
        return new ConcreteIterator<Integer>(items);
    }
}

public interface Iterator<Item> {
    Item next();

    boolean hasNext();
}

public class ConcreteIterator<Item> implements Iterator {
    private Item[] items;
    private int position = 0;

    public ConcreteIterator(Item[] items) {
        this.items = items;
    }

    @Override
    public Object next() {
        return items[position++];
    }

    @Override
    public boolean hasNext() {
        return position < items.length;
    }
}

public class Client {
    
    public static void main(String[] args) {
        Aggregate aggregate = new ConcreteAggregate();
        Iterator<Integer> it = aggregate.createIterator();
        while(iterator.hasNext()){
            System.out.println(iterator.next());
        }
    }
}
```

+ `中介者` `Mediator`：**集中相关对象之间复杂的沟通和控制方式**
    + `Mediator`：中介者，定义一个接口用于与各同事(`Colleague`)对象通信
    + `Colleague`：同事，相关对象

中介者模式又称为调停者模式，从类图中看，共分为3部分

1. 抽象中介者：`Medaitor`，定义好同事类对象到中介者对象的接口，用于各个同事类之间的通信。一般包括一个或几个抽象的事件方法，并由子类去实现。
2. 中介者实现类：`ConcreteMediator`，从抽象中介者继承而来，实现抽象中介者中定义的事件方法。从一个同事类接收消息，然后通过消息影响其他同事类。
3. 同事类：`Colleague`，如果一个对象会影响其他的对象，同时也会被其他对象影响，那么称这两个对象称为同事类。在类图中，同事类只有一个，这其实是现实的省略，在实际应用中，同事类一般由多个组成，它们之间相互影响，相互依赖。同事类越多，关系越复杂。在中介者模式中，**同事类之间必须通过中介者才能进行消息传递**。

> 一般来说，`同事类`之间的关系是比较复杂的，多个`同事类`之间互相关联时，他们之间的关系会呈现为复杂的`网状结构`，这是一种过度耦合的架构，不利于类的复用，也不稳定。如果引入`中介者模式`，那么`同事类`之间的关系将变为`星型结构`，任何一个类的变动，只会影响`本身`以及`中介者`，这样就减小系统的耦合。一个好的设计，必定不会把所有的对象关系处理逻辑封装在本类中，而是使用一个专门的类来管理那些不属于自己的行为。

```java

public abstract class Colleague {
    public abstract void onEvent(Mediator mediator);
}

public class Alarm extends Colleague {
    @Override
    public void onEvent(Mediator mediator) {
        mediator.doEvent("alarm");
    }

    public void doAlarm() {
        System.out.println("doAlarm()");
    }
}

public class CoffeePot extends Colleague {
    @Override
    public void onEvent(Mediator mediator) {
        mediator.doEvent("coffeePot");
    }

    public void doCoffeePot() {
        System.out.println("doCoffeePot()");
    }
}

public class Calender extends Colleague {
    @Override
    public void onEvent(Mediator mediator) {
        mediator.doEvent("calender");
    }

    public void doCalender() {
        System.out.println("doCalender()");
    }
}

public class Sprinkler extends Colleague {
    @Override
    public void onEvent(Mediator mediator) {
        mediator.doEvent("sprinkler");
    }

    public void doSprinkler() {
        System.out.println("doSprinkler()");
    }
}

public abstract class Mediator {
    public abstract void doEvent(String eventType);
}

public class ConcreteMediator extends Mediator {
    private Alarm alarm;
    private CoffeePot coffeePot;
    private Calender calender;
    private Sprinkler sprinkler;

    public ConcreteMediator(Alarm alarm, CoffeePot coffeePot, Calender calender, Sprinkler sprinkler) {
        this.alarm = alarm;
        this.coffeePot = coffeePot;
        this.calender = calender;
        this.sprinkler = sprinkler;
    }

    @Override
    public void doEvent(String eventType) {
        switch (eventType) {
            case "alarm":
                doAlarmEvent();
                break;
            case "coffeePot":
                doCoffeePotEvent();
                break;
            case "calender":
                doCalenderEvent();
                break;
            default:
                doSprinklerEvent();
        }
    }

    public void doAlarmEvent() {
        alarm.doAlarm();
        coffeePot.doCoffeePot();
        calender.doCalender();
        sprinkler.doSprinkler();
    }

    public void doCoffeePotEvent() {
        // ...
    }

    public void doCalenderEvent() {
        // ...
    }

    public void doSprinklerEvent() {
        // ...
    }
}

public class Client {
    public static void main(String[] args) {
        Alarm alarm = new Alarm();
        CoffeePot coffeePot = new CoffeePot();
        Calender calender = new Calender();
        Sprinkler sprinkler = new Sprinkler();
        Mediator mediator = new ConcreteMediator(alarm, coffeePot, calender, sprinkler);
        // 闹钟事件到达，调用中介者就可以操作相关对象
        alarm.onEvent(mediator);
    }
}
```

+ `备忘录 Memento`：**在不违反封装的情况下获得对象的内部状态，从而在需要时可以将对象恢复到最初状态。**

1. Originator：原始对象
2. Caretaker：负责保存好备忘录
3. Memento：备忘录，存储原始对象的状态。备忘录实际上有两个接口，一个是提供给Caretaker的窄接口：它只能将备忘录传递给其他对象；一个是提供给Originator的宽接口，允许它访问到先前状态所需的所有数据。理想情况是只允许Originator访问本备忘录的内部状态。

以下实现了一个简单计算器程序，可以输入两个值，然后计算两个值的和，备忘录模式允许将这两个值存储起来，然后在某个时刻用储存的状态进行恢复。

```java
public interface Calculator {

    PreviousCalculationToCareTaker backupLastCalculation();

    void restorePreviousCalculatoin(PreviousCalculationToCareTaker memento);

    int getCalculationResult();

    void setFirstNumber(int firstNumber);

    void setSecondNumber(int secondNumber);
}

public class CalcuatorImp implemnets Calculator {

    private int firstNumber;
    private int secondNumber;

    @Override
    public PreviousCalculationToCareTaker backupLastCalculation() {
        return new PreviousCalculationImp(firstNumber, secondNumber);
    }

    @Override
    public void restorePreviousCalculation(PreviousCalculationToCareTaker memento) {
        this.firstNumber = ((PreviousCalculationToOriginator)memento).getFirstNumber();
        this.secondNumber = ((PreviousCalculationToOriginator)memento).getSecondNumber();
    }
}

public interface PreviousCalculationToCareTaker {
}

public class PreviousCalculationImp implements PreviousCalculationToCareTaker, PreviousCalculationToOriginator {
    private int firstNumber;
    private int secondNumber;

    public PreviousCalculationImp(int firstNumber, int secondNumber) {
        this.firstNumber = firstNumber;
        this.secondNumber = secondNumber;
    }

    @Override
    public int getFirstNumber() {
        return firstNumber;
    }

    @Override
    public int getSecondNumber() {
        return secondNumber;
    }
}

public class Client {
    public static void main() {
       Calculator calculator = new Calculator();
       calculator.setFirstNumber(10);
       calculator.setSecondNumber(100);

       System.out.println(calculator.getCalculationResult());

       PreviousCalculationToCareTaker memento = calculator.backupLastCalculation();
       calculator.setFirstNumber(17);
       calculator.setSecondNumber(-290);

       System.out.println(calculator.getCalculationResult());
       calculator.restorePreviousCalculation(memento);
       System.out.println(calculator.getCalculationResult());
    }
}
```

+ `观察者 Observer`：**定义对象之间的一对多依赖，当一个对象状态改变时，它的所有依赖都会收到通知并且自动更新状态。**

主题是被观察的对象，而其所有依赖者称为观察者。主题具有注册和移除观察者、并通知所有观察者的功能，主题是通过维护一张观察者列表来实现这些操作的。观察者的注册功能需要调用主题的`registerObserver`()方法。 

```java

public interface Subject {
    void registerObserver(Observer o);
    void removeObserver(Observer o);
    void notifyObserver(Observer o);
}

public class WeatherData implements Subject {
    private List<Observer> observers;
    private float temperature;
    private float humidity;
    private float pressure;
    
    public WeacherData() {
        observers = new ArrayList();
    }
    public void setMeasurements() {
        this.temperature = temperature;
        this.humidity = humidity;
        this.pressure = pressure;
        notifyObserver();
    }   
    @Override
    public void registerObserver(Observer o) {
        observers.add(o);
    }
    @Override
    public void removeObserver(Observer o) {
        int i = observers.indexOf(o);
        if (i >= 0) {
            observers.remove(i);
        }
    }
    @Override
    public void notifyObserver() {
        for (Observer o : observers) {
            o.update(temperature, humidity, pressure);
        }
    }
}

public interface Observer {
    void update(float temp, float humidity, float pressure);
}

public class StatisticsDisplay implements Observer {
    public StatisticsDisplay(Subject weacherData) {
        weacherData.registerObserver(this);
    }
    @Override
    public void update(float temp, float humidity, float pressure) {
        System.out.println("StatisticsDisplay.update: "+temp+" "+humidity+" "+pressure);
    }
}

public class CurrentConditionsDisplay implements Observer {
    public CurrentConditionsDisplay(Subject weacherData) {
        weacherData.registerObserver(this);
    }
    @Override
    public void update(float temp, float humidity, float pressure) {
        System.out.println("CurrentConditionsDisplay.update: "+temp+" "+humidity+" "+pressure);
    }
}

public class WeacherStation {
    public static void main(String[] args) {
        WeatherData weatherData = new WeatherData();
        CurrentConditionsDisplay currentConditionsDisplay = new CurrentConditionsDisplay();
        StatisticsDisplay statisticsDisplay = new StatisticsDisplay(weatherData);
        
        weatherData.setMeasurements(0, 0, 0);
        weatherData.setMeasurements(1, 1, 1);
    }
}
```

+ `状态 state`： **允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它所属的类。**

糖果销售机有多种状态，每种状态下销售机有不同的行为，状态可以发生转移，使得销售机的行为也发生改变。
    
```java

public interface State {
    void insertQuarter();
    void ejectQuarter();
    void turnCrank();
    void dispense();
}
public class GumballMachine {
    private State soldOutState;
    private State noQuarterState;
    private State hasQuarterState;
    private State soldState;
    private State state;
    private int count = 0;
    
    public GumballMachine(int numberGumballs) {
        count = numberGumballs;
        soldOutState = new SoldOutState(this);
        noQuarterState = new NoQuarterState(this);
        hasQuarterState = new HasQuarterState(this);
        soldState = new SoldState(this);
        if (numberGumballs > 0) {
            state = noQuarterState;
        } else {
            state = soldQuarterState;
        }
    }
    public void insertQuarter() {
        state.insertQuarter();
    }
    public void ejectQuarter() {
        state.ejectQuarter();
    }
    public void turnCrank() {
        state.turnCrank();
    }
    public void setState(State state) {
        this.state = state;
    }
    public void releaseBall() {
        System.out.println("A gumball comes rolling out the slot ...");
        if (count != 0) {
            count -= 1;
        }
    }
    public State getSoldOutState() {
        return soldOutState;
    }
    public State getNoQuarqterState() {
        return noQuarterState;
    }
    public State getHasQuarterState() {
        return hasQuarterState;
    }
    public State getSoldState() {
        return soldState;
    }
    public int getCount() {
        return count;
    }
}

public class HasQuarterState implements State {
    private GumballMachine gumballMachine;
    
    public HasQuarterState(GumballMachine gumballMachine) {
        this.gumballMachine = gumballMachine;
    }
    @Override
    public void insertQuarter() {
        System.out.println("You can't insert another quarter");
    }
    @Override
    public void ejectQuarter() {
        System.out.println("Quarter returned");
        gumballsMachine.setState(gumballMachine.getNoQuarterState());
    }
    @Override
    public void turnCrank() {
        System.out.println("You turned ...");
        gumballMachine.setState(gumballMachine.getSoldState());
    }
    @Override
    public void dispense() {
        System.out.println("No gumball dispensed");
    }
}

public class NoQuarterState implements State {
 // ...
}

public class SoldOutState implements State {
 // ...
}

public class SoldState implements State {
 // ...
}

public class Client {
    GumballMachine gumballMachine = new GumballMachine(5);
    gumballMachine.insertQuarter();
    gumballMachine.turnCrank();
    gumballMachine.insertQuarter();
}
```

+ `策略 Strategy` ： **定义一系列算法，封装每个算法，并使它们可以互换。策略模式可以让算法独立于使用它的客户端。**

1. Strategy 接口定义了一个算法族，它们都实现了behavior方法
2. Context是使用到该算法族的类，其中的doSomething方法会调用behavior，setStrategy(Strategy)方法可以动态地改变strategy对象，也就是说能动态地改变Context所使用的算法。

> 状态模式的类图和策略模式类似，并且都是能够动态改变对象的行为。但是状态模式是通过状态转移来改变Context所组合的State对象，而策略模式是通过Context本身的决策来改变组合的Strategy对象。所谓的状态转移，是指Context在运行过程中由于一些条件发生改变而使得State对象发生改变，注意必须要是在运行过程中。

> 状态模式主要是用来解决状态转移的问题，当状态发生转移了，那么Context对象就会改变它的行为；而策略模式主要是用来封装一组可以互相替代的算法族，并且可以根据需要动态地去替换Context使用的算法。

设计一个鸭子，它可以动态地改变叫声，这里的算法族是鸭子的叫声行为。

```java
public interface QuackBehavior {
    void quack();
}

public class Quack implements QuackBahavior {
    @Override
    public void quack() {
        System.out.println("quack!");
    }
}

public class Squeak implements QuackBehavior {
    @Override
    public void quack() {
        System.out.println("squeak!");
    }
}

public class Duck {
    private QuackBehavior quackBehavior;
    public void performQuack() {
        if (quackBehavior != null) {
            quackBehavior.quack();
        }
    }
    public void setQuackBehavior(QuackBehavior quackBehavior) {
        this.quackBehavior = quackBehavior;
    }
}

public class Client {
    public static void main(String[] args) {
        Duck duck = new Duck();
        duck.setQuackBehavior(new Squeak());
        duck.performQuack();
        duck.setQuackBehavior(new Quack());
        duck.performQuack();
    }
}
```

+ `模板方法 Template Method` ：**定义算法框架，并将一些步骤的实现延迟到子类。通过模板方法，子类可以重新定义算法的某些步骤，而不用改变算法的结构。 **

冲咖啡和冲茶都有类似的流程，但是因为某些步骤会有点不一样，要求复用那些相同步骤的代码。

```java
public abstract class CaffeineBeverage {
    final void prepareRecipe() {
        boilWater();
        brew();
        pourInCup();
        addCondiments();
    }
    abstract void brew();
    abstract void addCondiments();
    void boilWater() {
        System.out.println("boilWater");
    }
    void pourInCup() {
        System.out.println("pourInCup");
    }
}
```

+ `访问者 visitor` ： **为一个对象结构增加新能力**

1. Visitor：访问者，为每一个ConcreteElement声明一个visit操作
2. ConcreteVisitor：具体访问者，存储遍历过程中的累计结果
3. ObjectStructure：对象结构，可以是组合结构，或者是一个集合

```java
public interface Element {
    void accept(Visitor visitor);
}
class CustomerGroup {
    private List<Customer> customers = new ArrayList();
    void accept(Visitor visitor) {
        for (Customer customer : customers) {
            customer.accept(visitor);
        }
    }
    void addCustomer(Customer customer) {
        customers.add(customer);
    }
}
public class Customer implements Element {
    private String name;
    private List<Order> orders = new ArrayList();
    Customer(String name) {
        this.name = name;
    }
    String getName() {
        return name;
    }
    void addOrder(Order order) {
        orders.add(order);
    }
    public void accept(Visitor visitor) {
        visitor.visit(this);
        for (Order order : orders) {
            order.accept(visitor);
        }
    }
}
public class Order implements Element {
    private String name;
    private List<Item> items = new ArrayList();
    Order(String name) {
        this.name = name;
    }
    Order(String name, String itemName) {
        this.name = name;
        this.addItem(new Item(itemName));
    }
    String getName() {
        return name;
    }
    void addItem(Item item) {
        items.add(item);
    }
    public void accept(Visitor visitor) {
        visitor.visit(this);
        for (Item item : items) {
            item.accept(visitor);
        }
    }
}
public class Item implements Element {
    private String name;
    Item(String name) {
        this.name = name;
    }
    String getName() {
        return name;
    }
    public void accept(Visitor visitor) {
        visitor.visit(this);
    }
}
public interface Visitor {
    void visit(Customer customer);
    void visit(Order order);
    void visit(Item item);
}
public class GeneralReport implements Visitor {
    private int customersNo;
    private int ordersNo;
    private int itemsNo;
    public void visit(Customer customer) {
        System.out.println(customer.getName());
        customersNo++;
    }
    public void visit(Order order) {
        System.out.println(order.getName());
        ordersNo++;
    }
    public void visit(Item item) {
        System.out.println(item.getName());
        itemsNo++;
    }
    public void displayResults() {
        System.out.println(customersNo);
        System.out.println(itemsNo);
        System.out.println(ordersNo);
    }
}

public class Client {
    public static void main(String[] args) {
        Customer customer1 = new Customer("customer1");
        customer1.addOrder(new Order("order1", "item1"));
        customer1.addOrder(new Order("order2", "item1"));
        customer1.addOrder(new Order("order3", "item1"));
        
        Order order = new Order("order_a");
        order.addItem(new Item("item_a1"));
        order.addItem(new Item("item_a2"));
        order.addItem(new Item("item_a3"));
        
        Customer customer2 = new Customer("customer2");
        customer2.addOrder(order);
        
        CustomerGroup customers = new CustomerGroup();
        customers.addCustomer(customer1);
        customers.addCustomer(customer2);
    
        GeneralReport visitor = new GeneralReport();
        customers.accept(visitor);
        visitor.displayResults();
    }
}
```

#### 结构型

+ `适配器` `Adapter` ：**把一个类接口转换称另一个用户需要到接口。**

鸭子和火鸡拥有两种不同的叫声，鸭子的叫声调用quack方法，而火鸡调用gobble方法。要求将火鸡的gobble方法适配成鸭子的quack方法，从而让火鸡冒充鸭子

```java
public interface Duck {
    void quack();
}
public interface Turkey {
    void gobble();
}
public class WildTurkey implements Turkey {
    @Override
    public void gobble() {
        System.out.println("gobble!");
    }
}
public class TurkeyAdapter implements Duck {
    Turkey turkey;
    
    public TurkeyAdapter(Turkey turkey) {
        this.turkey = turkey;
    }
    @Override
    public void quack() {
        turkey.gobble();
    }
}
public class Client {
    public static void main(String[] args) {
        Turkey turkey = new WildTurkey();
        Duck duck=  new TurkeyAdapter(turkey);
        duck.quack();
    }
}
```

+ `桥接` `Bridge`：将抽象与实现分离开来，使他们可以独立变化

1. `Abstraction` : 定义抽象类的接口
2. `Implementor` ： 定义实现类的接口

RemoteControl表示遥控器，指代Abstraction。TV表示电视，指代Implementor。桥接模式将遥控器和电视分离开来，从而可以独立改变遥控器或者电视的实现。

```java
public abstract class TV {
    public abstract void on();
    public abstract void off();
    public abstract void tuneChannel();
}
public class Sony extends TV {
    @Override
    public void on() {
       System.out.println("Sony.on()");
    }
    @Override
    public void off() {
        System.out.println("Sony.off()");
    }
    @Override   
    public void tuneChannel() {
        System.out.println("Sony.tuneChannel()");
    }
}
```

+ `组合` `Composite` ：**将对象组合成树形结构来表示"整体/部分"层次关系，允许用户以相同的方式处理单独对象和组合对象。**

组件类是组合类和叶子类的父类，可以把组合类看成是树的中间节点。组合对象拥有一个或者多个组件对象，因此组合对象的操作可以委托给组件对象去处理，而组件对象可以是另一个组合对象或者叶子对象。

+ `装饰` `Decorator` ： **为对象动态添加功能**

装饰者(`Decorator`)和具体组件(`ConcreteComponent`)都继承自组件(`Component`)，具体组件的方法实现不需要依赖于其他对象，而装饰者组合了一个组件，这样它可以装饰其他装饰者或者具体组件。所谓装饰，就是把这个装饰者套在被装饰者之上，从而动态扩展被装饰者的功能。装饰者的方法有一部分是自己的，这属于它的功能，然后调用被装饰者的方法实现，从而也保留了被装饰者的功能。可以看到，具体组件应当是装饰层次的最底层，因为只有具体组件的方法实现不需要依赖于其他对象。

> 设计原则：类应该对扩展开放，对修改关闭。也就是添加新功能时不需要修改代码。饮料可以动态添加新的配料，而不需要去修改饮料的代码。

+ `门面` `Facade` ：**提供了一个统一的接口，用来访问子系统中的一群接口，从而让子系统更容易使用。**

> 设计原则：只和你的密友谈话，也就是说客户对象所需要交互的对象应当尽可能的少。

+ `享元` `Flyweight` ：**利用共享的方式来支持大量细粒度的对象，这些对象一部分内部状态是相同的。**

1. Flyweight : 享元对象
2. IntrinsicState : 内部状态，享元对象共享内部状态
3. ExtrinsicState : 外部状态，每个享元对象的外部状态不同

+ `代理` `Proxy` : **控制对其他对象的访问**

1. 远程代理 Remote Proxy : 控制对远程对象的访问，它负责将请求及其参数进行编码，并向不同地址空间中的对象发送已经编码的请求。
2. 虚拟代理 Virtual Proxy : 根据需要创建开销很大的对象，它可以缓存实体的附加信息，以便延迟对它的访问，例如在网站加载一个很大图片时，不能马上完成，可以用虚拟代理缓存图片的大小信息，然后生成一张临时图片代替原始图片。
3. 保护代理 Protection Proxy : 按权限控制对象的访问，它负责检查调用者是否具有实现一个请求所必须的访问权限。
4. 智能代理 Smart Proxy : 取代了简单的指针，它在访问对象时执行一些附加操作；记录对象的引用次数，当第一次引用一个对象时，将它装入内存；在访问一个实际对象前，检查是否已经锁定了它，以确保其他对象不能改变它。

### 设计原则

+ 单一责任原则

> 修改一个类的原因应该只有一个

换句话说就是让一个类只负责一件事，当这个类需要做过多事情时，就需要分解这个类。如果一个类承担的指责过多，就等于把这些职责耦合在一起，一个职责的变化可能会削弱这个类完成其他职责的能力。

+ 开放封闭原则

> 类应该对扩展开放，对修改关闭

扩展就是添加新功能的意思，因此该原则要求在添加新功能时不需要修改代码。符合开闭原则最典型的设计模式就是`装饰者模式`，它可以动态地将责任附加到对象上，而不用去修改类的代码。

+ 里氏替换原则

> 子类对象必须能够替换掉所有父类对象

继承是一种`IS-A`关系，子类需要能够当成父类来使用，并且需要比父类更特殊。如果不满足这个原则，那么各个子类的行为上就会有很大差异，增加继承体系的复杂度。

+ 接口分离原则

> 不应该强迫客户依赖于它们不用的方法

因此使用多个专门的接口比使用单一的总接口要好

+ 依赖倒置原则

> 高层模块不应该依赖于底层模块，二者都应该依赖于抽象；抽象不应该依赖于细节，细节应该依赖于抽象。

高层模块包含一个应用程序中重要的策略选择和业务模块，如果高层模块依赖于底层模块，那么底层模块的改动就会直接影响到高层模块，从而迫使高层模块也需要改动。

依赖于抽象意味着：

1. 任何变量都不应该有一个指向具体类的指针或者引用
2. 任何类都不应该从具体类派生
3. 任何方法都不应该覆写它的任何基类中的已经实现的方法

+ 迪米特法则

> LKP，最少知识原则，一个对象应当对其他对象有尽可能少的了解，不和陌生人说话。

+ 合成复用原则

> 尽量使用对象组合，而不是通过继承来达到复用的目的

+ 共同封闭原则

> 一起修改的类，应该组合在一起(同一个包里)。如果必须修改应用程序的代码，我们希望所有的修改都发生在一个包里(修改关闭)，而不是遍布在很多包里。

+ 稳定抽象原则

> 最稳定的包应该是最抽象的包，不稳定的包应该是具体的包，即包的抽象程度跟他的稳定性成正比

+ 稳定依赖原则

> 包之间的依赖关系都应该是稳定方向依赖的，包要依赖的包要比自己更具有稳定性
