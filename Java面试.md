[TOC]

# 常见问答


### 阻塞队列的实现

阻塞队列 (`BlockingQueue`)是Java `util.concurrent`包下重要的数据结构，`BlockingQueue`提供了线程安全的队列访问方式：当阻塞队列进行插入数据时，如果队列已满，线程将会阻塞等待直到队列非满；从阻塞队列取数据时，如果队列已空，线程将会阻塞等待直到队列非空。并发包下很多高级同步类的实现都是基于`BlockingQueue`实现的。

### await方法是怎么实现的？

> 当前线程进入等待状态直到被通知(`signal`)或中断，当前线程进入后台运行状态且从`await()`方法返回其他线程调用该`Condition`的`signal`或者`signalAll`方法，而当前线程被选中唤醒

1. 其他线程(`interrupt`)中断当前线程
2. 如果当前等待线程从`await`方法返回，那么表明当前线程已经获取了`Condition`对象的锁


### wait方法调用

`wait()`需要和`synchronized`搭配使用，用于线程同步。`wait()`总是在一个循环中被调用，挂起来当前线程来等待一个条件的成立。`wait`调用会一直等到其他线程调用`notifyAll()`时才返回。

当一个线程在执行`synchronized`的方法内部，调用了`wait()`后，该线程会释放该对象的锁，然后该线程会被添加到该对象的等待队列中，只要该线程在等待队列中，就会一直处于闲置状态，不会被调度执行。要注意`wait()`方法会强迫线程先进行释放锁操作，所以在调用`wait()`时，该线程必须已经获得锁，否则会抛出异常。由于`wait()`在`synchronized`的方法内部被执行，锁一定已经获得，就不会抛出异常了。

### 线程池参数说明

+ corePoolSize

创建了线程池后，默认初始没有任何线程，等待任务来后才创建线程。超过核心线程数后，放入阻塞队列。

+ maxPoolSize

当线程数大于等于`corePoolSize`，并且任务阻塞队列已满时，线程池会创建新的线程，直到线程数达到`maxPoolSize`。当线程数达到`maxPoolSize`，且任务阻塞队列已满，这时候线程池会拒绝处理任务而抛出异常。

+ keepAliveTime

当线程空闲时间达到`keepAliveTime`，该线程会退出，直到线程数等于`corePoolSize`。如果设置了`allowCoreThreadTimeout`为true，则所有线程都会退出。

+ 参数设置说明
    + tasks 每秒的任务数，假设为500-1000
    + taskcost 每个任务花费的时间，假设为0.1s
    + responsetime 系统允许容忍的最大响应时间，假设为1s


`corePoolSize`：每秒需要处理多少个任务 => tasks * taskcost
`queueCapaticy`: 每秒可以缓存多少个任务 => 
`maxPoolSize`: 每秒可以缓存多少个任务 => tasks-corePoolSize

> 网上的例子没有权威性，全TM是国内的码农抄来抄去的代码和博客。

这里使用固定线程数线程池的创建，即`corePoolSize`与`maxPoolSize`数一致，该值使用如下获取

```java
Runtime.getRuntime().availableProcessors() * 50;
```

这种设置线程数的方式，在`StackOverFlow`看得有点多，而且`hsweb`开源项目也是使用这种方法的

### 死锁如何产生？如何防范死锁

+ 死锁发生的情形

    + 一个线程两次申请锁 （`第一次申请成功，第二次重复申请，这时候无法获取到被第一次时申请到的锁，造成拥有锁的线程挂起`）

    + 两个线程互相申请对方的锁，但是对方都不释放锁

+ 死锁产生的必要条件

    + 互斥：一次只有一个进程可以使用一个资源。其他进程不能访问已分配给其他进程的资源。
    + 占有且等待：当一个线程在等待分配得到其他资源时其继续占有已分配得到的资源。
    + 非抢占：不能强行抢占进程中已占有的资源。
    + 循环等待：存在一个封闭的进程链，使得每个资源至少占有此链中下一个进程所需要的一个资源。

+ 处理死锁的四种方法

    + 死锁预防：通过确保死锁的一个必要条件不会满足，保证不会发生死锁
    + 死锁检测：允许死锁的发生，但是可以通过系统设置的检测结构及时的检测出死锁的发生，采取一些措施，将死锁清除掉
    + 死锁避免：在资源分配过程中，使用某种方法避免系统进入不安全的状态，从而避免发生死锁
    + 死锁解除：与死锁检测相配套的一种措施。当检测到系统中已发生死锁，需将进程从死锁状态中解脱出来。

+ 避免死锁的方法

    + 银行家算法：每一个线程进入系统时，它必须声明在运行过程中，所需的每种资源类型的最大数目，其数目不应超过系统所拥有每种资源总量，当线程请求一组资源，系统必须确定有足够资源分配给该线程，若有在进一步计算这些资源分配给进程后，是否会使系统处于不安全状态，不会的话则分配资源，否则等待。


### volatile的作用，与锁的区别，会有线程不安全的情况吗？

线程安全的两个方面：`执行控制`和`内存可见`

+ 执行控制：控制代码执行顺序及是否可以并发执行
+ 内存可见：控制线程执行结果在内存中对其他线程的可见性。根据`Java内存模型`的实现，线程在具体执行时，会先拷贝主存数据到线程本地，操作完成后再把结果从线程本地刷新到主存。


`synchronized` 解决的是执行控制的问题，他会阻止其他线程获取当前对象的监控锁，这样就使得当前对象中被`synchronized`关键字保护的代码块无法被其他线程访问，也就无法并发执行。更重要的是，`synchronized`还会创建一个`内存屏障`，内存屏障指令保证了所有CPU操作结果都会直接刷到主存中，从而保证了操作的内存可见性，同时也使得先获得这个锁的线程的所有操作，都`happens-before`于随后获得这个锁的线程的操作。

> 在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在 `happens-before` 关系

`happens-before`原则非常重要，它是判断数据是否存在竞争、线程是否安全的主要依据，依靠这个原则，我们解决在并发环境下两操作之间是否可能存在冲突的所有问题。下面就一个简单的例子稍微了解

```java

i = 1;  // 线程A执行
j = i;  // 线程B执行

```

j是否等于1呢？假定线程A的操作`happens-before`于线程B的操作，那么可以确定线程B执行后`j=1`一定成立。

+ 如果一个操作`happens-before`另一个操作，那么第一个操作的执行结果将对第二个操作可见，而且第一个操作的执行顺序排在第二个操作之前。
+ 两个操作之间存在`happens-before`关系，并不意味着一定要按照`happens-before`原则制定的顺序来执行。如果重排序之后的执行结果与按照`happens-before`关系来执行的结果一致，那么这种重排序并不非法。

`volatile`解决的是内存可见性的问题，会使得所有对`volatile`变量的读写都会直接刷到主存，即保证了变量的可见性。

> 使用`volatile`关键字仅能实现对原始变量(`如boolean、short、int、long等`)操作的原子性，但需要特别注意，`volatile`不能保证复合操作的原子性，即使只是`i++`，实际上也是由多个原子性操作组成。

对于`volatile`关键字，当且仅当满足以下所有条件时可使用：

+ 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值
+ 该变量没有包含在具有其他变量的不变式中


`volatile`和`synchronized`的区别

+ `volatile`本质是在告诉jvm当前变量在寄存器中的值是不确定的，需要从主存中读取；`synchronized`则是锁定当前变量，只有当前线程可以访问该变量，其他线程被阻塞住。

+ `volatile`仅能使用在变量级别；`synchronized`则可以使用在变量、方法和类级别的
+ `volatile`仅能实现变量的修改可见性，不能保证原子性；而`synchronized`则可以保证变量的修改可见性和原子性
+ `volatile`不会造成线程的阻塞，`synchronized`可能会造成线程的阻塞
+ `volatile`标记的变量不会被编译器优化，`synchronized`标记的变量可以被编译器优化。


### ThreadLocal是怎么实现的？

理论上，用`map`存放线程对象和值的键值对就可以实现`ThreadLocal`的功能，但是性能上不是最优的，多线程访问`ThreadLocal`的`map`对象会导致并发冲突，用`synchronized`加锁会导致性能上的损失。因此，`JDK7`里是将map对象保存在线程里，这样每个线程去取自己的数据，就不需要加锁保护的。


### 熔断、降级、限流、负载均衡

+ 熔断：熔断模式可以防止应用程序不断地尝试可能超时和失败的服务，能达到应用程序执行而不必等待下游服务修正错误服务

+ 降级：降级就是为了解决资源不足和访问量增加的矛盾。在有限的资源情况下，为了能抗住大量的请求，就需要对系统做出一些牺牲，有点弃卒保帅的意思。放弃一些功能，保证整个系统能平稳运行。

+ 限流：通过对并发访问进行限速。

限流的实现方式

+ 计数器

最简单的实现方式，维护一个计数器，来一个请求数加一，达到阈值时，直接拒绝请求。一般使用`nginx + lua + redis`这种方式，`redis`存计数值。

+ 漏斗模式

漏斗很多是用一个队列实现的，当流量过多时，队列会出现积压，队列满了，则开始拒绝请求。

+ 令牌桶

处理请求时，先拿到token才处理，当令牌桶没有令牌时，不处理请求。

### 服务端负载均衡与客户端负载均衡的区别？


+ 服务端负载均衡：通过`nginx`负载均衡服务器发送到不同的上游服务器去处理。

+ 客户端负载均衡：类似微服务的服务发现这个场景。`ribbon`是基于HTTP的客户端负载均衡器，从`eureka`服务注册中心获取服务端列表，然后进行轮询访问以达到负载均衡的作用。

### 消息队列的区别对比，消息丢失的情况有哪些？如何确保消息不丢失。

| 对比项 | RabbitMQ | RocketMQ | ActiveMQ | Kafka |
|:---:|:---:|:---:|:---:|:---:|
|消息推拉模式|多协议，Pull/Push均有支持|多协议，Pull/Push均有支持|多协议，Pull/Push均有支持|Pull|
|客户端支持语言|几乎支持所有常用语言|Java、C、C++、Python、PHP、Perl等大部分|Java、C++|支持大部分|
|消息批量操作|不支持|支持|支持|支持|
|单机吞吐量|万级|万级|十万级|十万级|
|事务|不支持|支持|支持|不支持，但可以通过`Low Level Api`保证仅消费一次|

+ 消息丢失的情况

    + 生产者往MQ写数据丢失

        可能因为网络原因，数据传输丢失

    + MQ本身数据丢失了

        数据放在内存中，MQ机器宕机了，那么内存中的数据丢失了

    + 消费者消费消息时丢失了

       消费者接受到消息，马上给`MQ`返回已经接受到消息的回复(`自动ACK`)，消费者接着处理逻辑，在处理过程中，消费者宕机了；下次重启的时候，消费者会获取到下一条数据消费，这样数据就丢失了。 

+ 解决消息丢失的问题

    + 解决生产者丢失数据

        1. 在生产者发送消息的时候，加上事务。缺点是，加上事务之后，消息变成同步了，影响吞吐量，比较耗性能。
        2. `confirm机制`，在生产者开启`confirm机制`，每个消息分配唯一`id`，生产者发送完消息之后就不用管了，`rabbitmq`如果成功接收到消息，那么就会调用生产者的`ack`方法，`rabbitmq`如果接收失败，那么会调用生产者的`nack`方法，生产者根据情况判断是否要重试。

        > 一般情况下，使用`confirm模式`，性能、吞吐量都要比事务机制高。`confirm`是异步的，不会阻塞。

    + 解决`MQ`丢失数据

        1. 开启持久化，把内存中的数据刷新到磁盘中。如果在写入磁盘的时候挂了，这样的话还是有数据丢失，但是可以等数据持久化到磁盘，再通知生产者`ack`方法，如果没有持久化成功，生产者长时间没有收到消息可以尝试再重试一次。

    + 解决消费者丢失数据

        1. 关闭`自动ack`，等自己处理完之后再发送`ack`给`MQ`。

### redis的缓存策略

`redis`删除过期键的策略如下

+ 定时删除

    给key设置过期时间

    > 缺点是为每一个键实现一个定时器，会耗费较多的资源

+ 定期删除

    定期扫描一遍`expires`字典，将已过期的键删除

    > 缺点是不能保证所有的键过期时被及时删除，需在下一个定期删除区间内被扫描并删除

+ 惰性删除

    获取每一个`key`的时候，判断一下该`key`是否已经过期，如果已经过期则删除。
    > 如果一个key一直不使用，即使过了过期时间也会一直占用内存，大量的不使用的`key`会使得内存暴增。

`redis`采用了`定期删除`和`惰性删除`两种策略

### awk使用

`awk`处理列，`sed`处理行。

+ 打印某列数据

```shell
awk '{[pattern] action}' {filename}

awk '{print $1,$4}' log.txt
```

+ 使用分割符

```shell
awk -F, '{print $1,$2}' log.txt
```

+ 设置变量

```shell
awk -v
awk -va=1 '{print $1,$1+a}' log.txt
```

+ 执行awk脚本

```shell
awk -f {awk脚本} {文件名}
awk -f cal.awk log.txt
```

### 查看linux某个端口是否被占用

+ 使用lsof

```shell
lsof -i:80
```

+ 使用netstat

```shell
netstat | grep 80
```

### RabbitMQ高可用

RabbitMQ运行模式大致有3种

+ 单一模式

非集群模式，单机运行


+ 普通模式

RabbitMQ默认的集群模式。对于`Queue`来说，消息实体只存在于一个节点，A、B两个节点仅有相同的队列结构。当消息进入A节点的`Queue`，消费者从B节点拉取时，RabbitMQ会临时在A、B间进行消息传输，把A中的消息实体取出并经过B发送给消费者。

> 缺点是当A节点故障时，B节点无法取到A节点中还未消费的消息实体。

+ 镜像模式

`Queue`同时存在于多个节点，消息主体会主动在镜像节点之间同步，而不是在消费者拉取数据时临时出传输。

> 缺点是会降低系统性能。同时如果镜像队列过多，加之大量的消息进入，集群内部的网络带宽将会被这种同步通讯大大消耗掉。

### BIO、AIO和NIO区别

+ BIO

一个连接一个线程。同步并阻塞。客户端有连接请求时，服务器端就需要启动一个线程进行处理，如果这个连接不做任何事情会造成不必要的线程开销。

数据的读取写入必须阻塞在一个线程内等待其完成。

> 可以通过线程池机制改善

+ NIO

一个请求一个线程。同步非阻塞。客户端发送的连接请求都会注册到多路复用器上，多路复用器轮询到连接有I/O请求时才启动一个线程进行处理。


+ AIO

一个有效请求一个线程。异步非阻塞。客户端的I/O请求都是由OS先完成了再通知服务器应用去启动线程进行处理。


> AIO VS NIO ：NIO需要使用者线程不停的轮询IO对象，来确定是否有数据准备好可以读了，而AIO则是在数据准备好了之后，才会通知数据使用者，这样使用者就不需要不停地轮询了。

### Dubbo使用

> Dubbo是解决分布式服务问题的框架，是一个基于SOA面向服务体系结构的基础设施，提供了诸如服务发布注册、容错调用、部署、调用次数监控、每个服务的性能监控等很多功能。

核心部分包括


+ 远程通讯

提供多种基于长连接的NIO框架抽象封装，包括多种线程模型，序列化，以及“请求-响应“模式的信息交换方式

+ 集群容错

提供基于接口方法的透明远程过程调用，包括多协议支持，以及软负载均衡，失败容错，地址路由，动态配置等集群支持。

+ 自动发现

基于注册中心目录服务，使服务消费方能动态的查找服务提供方，使地址透明，使服务提供方可以平滑增加或减少机器。

核心组件包括

+ `Provider`

暴露服务的服务提供方

+ `Consumer`

调用远程服务的服务消费方

+ `Registry`

服务注册与发现的注册中心

+ `Monitor`

统计服务的调用次数和调用时间的监控中心

+ `Container`

服务运行容器

### BeanFactory和ApplicationContext有什么区别？


`ApplicationContext`和`BeanFactory`相比，提供了更多的扩展功能，但是这还不是主要区别，主要区别在于`BeanFactory`是延迟加载，举个例子：如果`Bean`没有完全注入，`BeanFactory`加载后，会在你第一次调用`GetBean`方法才会抛出异常；而`ApplicationContext`会在初始化的时候就加载并且检查，这样的好处是可以及时检查依赖是否完全注入

+ `ApplicationContext`是`BeanFactory`的子接口

### Spring Bean的生命周期

+ Bean自身的方法

包括了`Bean`本身调用的方法和通过配置文件中`<bean>`的`init-method`和`destroy-method`指定的方法。

+ Bean级生命周期接口方法

包括了`BeanNameAware`、`BeanFactoryAware`、`InitiallizingBean`和`DisposableBean`这些接口的方法。

+ 容器级生命周期接口方法

包括`InstantiationAwareBeanPostProcessor`和`BeanPostProcessor`这两个接口实现，一般称它们的实现类为`后处理器`

+ 工厂后处理器接口方法

包括了`AspectJWeavingEnabler`、`ConfigurationClassPostProcessor`，`CustomAutowireConfigurer`等等非常有用的工厂后处理器接口的方法。工厂后处理器也是容器级的，在应用上下文装配配置文件之后立即调用。

示例如下

1. 开始初始化容器
2. 进入`BeanFactoryPostProcessor`实现类的构造方法
3. `BeanFactoryPostProcessor`调用`postProcessBeanFactory`方法
4. 进入`BeanPostProcessor`实现类的构造方法
5. 进入`InstantiationAwareBeanPostProcessorAdapter`实现类的构造方法
6. `InstantiationAwareBeanPostProcessor`调用`postProcessBeforeInstantiation`方法
7. 调用`Person`类的构造方法实例化
8. `InstantiationAwareBeanPostProcessor`调用`postProcessPropertyValues`方法
9. 注入属性`address`
10. 注入属性`name`
11. 注入属性`phone`
12. 调用`BeanNameAware`.`setBeanName`()方法
13. 调用`BeanFactoryAware`.`setBeanFactory`()方法
14. `BeanPostProcessor`接口方法`postProcessBeforeInitialization`对属性进行更改
15. 调用`InitializingBean`.`afterPropertiesSet`()方法
16. 调用<bean>的`init-method`属性指定的初始化方法
17. `BeanPostProcessor`接口方法`postProcessAfterInitialization`对属性进行更改
18. `InstantiationAwareBeanPostProcessor`调用`postProcessAfterInitialization`方法
19. 容器初始化成功
20. Person [address=广州]
21. 开始关闭容器
22. 调用`DiposibleBan`.`destory`()
23. 调用<bean>的`destroy`-`method`属性指定的初始化方法

### Java类加载器

> 双亲委派模型，该机制可以避免重复加载，当父亲已经加载了该类的时候，就没有必要子`ClassLoader`再加载一次。JVM根据`类名+包名+ClassLoader实例ID`来判定两个类是否相同，是否已经加载过。(可以通过创建不同的`ClassLoader`实例来实现类的热部署)

+ `BootStrapClassLoader`

最顶层的类加载器，由C++编写而成，已经内嵌到`JVM`中。在JVM启动时会初始化该`ClassLoader`，它主要用来读取`Java`的核心类库`JRE/lib/rt.jar`中所有的`class`文件，这个`jar`文件中包含了`java`规范定义的所有接口及实现。

+ `ExtensionClassLoader`

用来读取`Java`的一些扩展类库，如读取`JRE/lib/ext/*.jar`中的包

+ `AppClassLoader`

用来读取`classpath`下指定的所有`jar`包或目录的类文件，一般情况下，这个就是程序默认的类加载器

+ `CustomClassLoader`

用户自定义编写的，用来读取指定类文件。基于自定义的`ClassLoader`可用于加载非`classpath`中（如从网络上下载的`jar`或二进制）的`jar`及目录、还可以在加载前对`class`文件优化一些动作，如解密、编码等

> `ExtensionClassLoader`的父类加载器是`BootStrapClassLoader`，其实这里省掉了一句话，容易造成很多新手的迷惑。严格说，`ExtClassLoader`的父类加载器是`null`，只不过是在默认的`ClassLoader
`的`loadClass`方法中，当`parent`为`null`时，是交给`BootStrapClassLoader`来处理的，而且`ExtClassLoader`没有重写默认的`loadClass`方法，所有，`ExtClassLoader`也会调用`BootStrapClassLoader`类加载器来加载。

### Java虚拟机 JVM

JVM主要包括四个部分

+ `类加载器` 在`JVM`启动时或者在类运行时将需要的`class`加载到`JVM`中


+ `执行引擎` 负责执行`class`文件中包含的字节码指令


+ `内存区` 在`JVM`运行时操作所分配的内存区。运行时内存区主要分为5个区域

    + `方法区` 用于存储类结构信息的地方，包括常量池、静态变量、构造方法等
    + `java堆` 存储`java`实例或者对象的地方。这块是`GC`的主要区域。从存储的内容可以知道，方法区和堆是被所有`java`线程共享的
    + `java栈` `java`栈总是和线程关联在一起，每当创建一个线程时，`JVM`就会为这个线程创建一个对应的`java`栈。在这个`java`栈中又会包含多个栈帧，每运行一个方法就创建一个栈帧，用于存储局部变量表、操作栈，方法返回值等。每一个方法从调用直至执行完成的过程，就对应一个栈帧在`java`栈中入栈到出栈的过程。 
    + `程序计数器` 用于保存当前线程执行的内存地址。由于`JVM`程序是多线程执行，所以为了保证线程切换回来后，还能恢复到原先状态，就需要一个独立的计数器，记录之前中断的地方，可见线程计数器也是线程私有的。

+ `本地方法栈` 和`java`栈的作用差不多，只不过是为了`JVM`使用到的`native`方法服务的。


### Java对象的生命周期


+ 创建阶段

    1. 为对象分配存储空间
    2. 开始构造对象
    3. 从超类到子类对`static`成员进行初始化
    4. 超类成员变量按顺序初始化，递归调用超类的构造方法
    5. 子类成员变量按顺序初始化，子类构造方法调用

+ 应用阶段
    对象被至少一个强引用持有者

+ 不可见阶段
    程序本身不再持有该对象的任何强引用，虽然这些引用仍然是存在着的，简单说就是程序的执行已经超出了该对象的作用域了。

```java

boolean bool = false;

if (bool == true) {
    int count = 0;
    count++;
}

System.out.println(count);

```

+ 不可达阶段

对象处于不可达阶段是指该对象不再被任何强引用所持有。与`不可见阶段`相比，该阶段指程序不再持有该对象的任何强引用，这种情况下，该对象仍可能被JVM等系统下的某些已装载的静态变量或线程或`JNI`等强引用持有者，这些特殊的强引用被称为`GC root`。存在这些`GC root` 会导致对象的内存泄漏情况，无法被回收。 

+ 收集阶段

当垃圾回收器发现该对象已经处于不可达阶段并且垃圾回收器已经对该对象的内存空间重新分配做好准备时，则对象进入了收集阶段。如果该对象已经重写了`finalize()`，则会去执行该方法的终端操作。

+ 终结阶段

当对象执行完`finalize()`方法后仍然处于不可达状态时，则该对象进入终结阶段。在该阶段是等待垃圾回收器对该对象空间进行回收。


+ 对象空间重分配阶段

垃圾回收器对该对象的所占用的内存空间进行回收或者再分配了，则该对象彻底消失了，称之为`对象空间重新分配阶段`



### 分布式技术


### 设计模式

