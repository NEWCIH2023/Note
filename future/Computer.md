[TOC]
------

# 计算机系统概述
## 计算机发展历程
## 计算机系统层次结构
+ 输入设备
+ 输出设备
+ 存储器
	+ MAR (Memory Address Register) 地址寄存器 - **存放访存地址，经过地址译码后找到所选的存储单元，用于寻址**
	+ MDR (Memory Data Register) 数据寄存器
+ 运算器
	+ ALU (Arithmetic And Logical Unit) 算术逻辑单元 - **运算器的核心**
	+ ACC (Accumulator) 累加器
	+ MQ (Multiple-Quotient Register) 乘商寄存器
	+ X 操作数寄存器
	+ IX 变址寄存器
	+ BR 基址寄存器
	+ PSW 程序状态寄存器/标志寄存器
+ 控制器
	+ PC (Program Counter) 程序计数器 - **存放当前欲执行指令的地址，可以自动加1以形成下一条指令的地址**
	+ IR (Instruction Register) 指令寄存器 - **存放当前的指令，数据来自主存的MDR**
	+ CU (Control unit) 控制单元

## 计算机的性能指标

+ 运算速度
	+ 主频和CPU时钟周期
		+ CPU时钟周期。即**主频的倒数**，是**CPU中最小的时间单位**，执行指令的每个动作至少需要1个时钟周期
		+ CPU时钟周期 = 1 / CPU主频
		+ 主频通常以**Hz**为单位，1Hz表示每秒1次。
	+ CPI (Clock cycle Per Instruction)
		+ 执行一条指令所需的时钟周期数
		+ 不同指令的时钟周期数可能不同，对一个程序或机器来说，其CPI指该程序或该机器指令集中所有的指令执行所需的平均时钟周期数，此时**CPI是一个平均值**
	+ CPU执行时间
		+ `CPU执行时间 = CPU时钟周期数 * CPU时钟周期 = CPU时钟周期数 / 主频 = (指令条数 * CPI) / 主频 = (指令条数 * CPI) * CPU时钟周期`
	+ MIPS (Million Instructions Per Second)
		+ 每秒执行多少百万条指令
		+ MIPS = 指令条数 / (执行时间 * 10^6) = 主频 / (CPI * 10^6)
	+ MFLOPS (Mega Floating-point Operations Per Second)
	+ GFLOPS (Giga Floating-point Operations Per Second)
	+ TFLOPS (Tera Floating-point Operations Per Second)
+ 主存容量
	+ 以`字节`衡量，也可用`字数 * 字长`，如`512K * 16`来表示
	+ MAR的位数，表示 **存储单元的个数**，MDR的位数，表示 **可寻址范围的最大值**
	+ MAR为16位，表示 2^16 = 65536，即有65536个存储单元（可称为64K内存），若MDR为32位，表示存储容量为 **64K * 32位**

## 总结

+ MDR, MAR虽然是存储器的一部分，但在现代CPU中，却是存在于CPU中，与高速缓存(Cache)一样
+ 在描述存储容量、文件大小等时，K、M、G、T通常用2的幂次表示，如1Kb = 2^10b；在描述速率、频率等时，k、M、G、T通常用10的幂次表示，如 1kb/s = 10^3 b/s。通常前者用大写的K，后者用小写的k，但其他前缀均为大写，表示的含义取决于所用的场景。
+ 翻译程序：把高级语言源程序翻译成机器语言程序（目标代码）的软件。有两种
	+ 编译程序：将高级语言源程序一次全部翻译成目标程序，每次执行程序时，只需执行目标程序。
	+ 解释型程序：将源程序的一条语句翻译成对应的机器目标代码，并立即执行，然后翻译下一条源程序语句并执行，直至所有源程序语句全部被翻译并执行完。（不会生成目标程序）
+ 汇编程序也是一种语言翻译程序，把汇编语言源程序翻译为机器语言程序。
+ 编译程序与汇编程序的区别：若源程序是 **C，C++，Java** 等高级语言，而目标语言是 **汇编语言，或机器语言** 之类的低级语言，则称这样的翻译程序为编译程序。若源语言是 **汇编语言**，而目标语言是 **机器语言**，则这样的翻译程序称为 **汇编程序**。
+ 在计算机领域，站在某类用户的角度，若感觉不到某个事物或属性的存在，即**“看”不到某个事物或属性*<!--  --> --><!--  -->*，则称为“对该用户透明”。与日常生活中的“透明”概念正好相反。
+ 在CPU中，IR，MAR和MDR对各类程序员都是透明的
+ 机器字长 VS 指令字长 VS 存储字长
	+ 机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。
	+ 指令字长：一个指令字中包含的二进制代码的位数。
	+ 存储字长：一个存储单元存储的二进制代码的长度。
	+ 指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令。

# 数据的表示和运算

## 数制与编码

+ 真值：带“+”或“-”符号的数称为真值
+ 机器数：把符号“数字化”的数称为机器数
+ 0 ~ 9 的ASCII码值为 **48 （011 0000） ~ 57 （011 1001）**，即去掉高3位，只保留低4位，正好是二进制形式的 0~9
+ BCD (Binary-Coded Decimal) 二进制编码的10进制数
+ 7E5H，H代表16进制
+ 进制转换
	+ 二进制转八进制、十六进制
		+ 以小数点为界，将一串二进制数分为3位一组或4位一组。整数部分，从左边开始补0，小数部分，从右边开始补0。
	+ 八进制、十六进制转二进制
		+ 只需将每位改为3位或4位二进制数即可
	+ 任意进制转十进制
		+ 保底法：如果存在小数部分，则根据二进制、八进制、十六进制，乘以对应的基数，每乘一次，就左移一位，直到全部是整数。这时候就通过位置法计算出十进制，然后再除以之前乘的数
		+ 将任意进制数的各位数码与它们的权值相乘，再把乘积相加，就得到了一个十进制数。这种方法称为按权展开相加法。
			+ (11011.1) = 1\*2^4 + 1\*2^3 + 0\*2^2 + 1\*2^1 + 1\*2^0 + 1\*2^-1 = 27.5
	+ 十进制转任意进制
		+ 整数部分用除基取余法，小数部分用乘基取整法，最后将整数部分和小数部分的转换结果拼接起来
		+ 除基取余法：**整数部分除基取余，最先取得的余数为数的最低位，最后取得的余数为数的最高位（即除基取余，先余为低，后余为高），`商为0` 时结束。
		+ 乘基取整法：**小数部分(乘基后如果出现整数部分，则整数部分不参与下一次乘基计算)乘基取整，最先取得的整数为数的最高位，最后取得的整数为数的最低位（即乘基取整，先整为高，后整为低），乘积为1.0（或满足精度要求）时结束。
		+ ![image-20220517164713443](../images/image-20220517164713443.png)
+ 校验码
	+ 奇偶校验码
		+ 实现方法：由若干位有效信息，再加上一个二进制位（校验位）组成校验码。校验码的取值（0或1）将使整个校验码中“1”的个数为奇数或偶数。
		+ 奇校验码：整个校验码（有效信息位和校验位）中“1”的个数为奇数
		+ 偶校验码：整个校验码（有效信息位和校验位）中“1”的个数为偶数
	+ 海明校验码 (Hamming Code，也称 **汉明码**，多重奇偶校验码，具有纠错能力)
		+ 实现方法：在有效信息位中加入几个校验位形成海明码，并把海明码的每个二进制位分配到几个奇偶校验组中。当某一位出错后，就会引起有关的几个校验位的值发生变化，这不但可以发现错位，还能指出错位的位置，为自动纠错提供依据。
		+ ** L(编码最小码距) - 1 = D(检测错误的位数) + C(纠正错误的位数) 且 D >= C **
		+ 编码最小码距L越大，其检测错误的位数D越大，纠正错误的位数C也越大，且纠错能力恒小于等于检错能力。

## 定点数的表示与运算
### 定点数的表示
+ 真值零的原码表示有 **正零** 和 **负零** 两种形式
+ 移位运算
	+ 有符号位的称 **算术移位**，**逻辑移位**的操作对象是逻辑代码，可视为无符号数。
	+ 算术移位的空位添补规则

	|码制|添补代码|
	|:---:|:---:|:--:|
	|正数|原码、补码、反码|0|
	|负数|原码|0|
	|负数|补码|左移添0，右移添1|
	|负数|反码|1|

	> 分析由原码得到补码的过程发现，当对其由低位向高位找到第一个“1”时，在此“1”左边的各位均与对应的反码相同，而在此“1”右边的各位（包括此“1”在内）均与对应的原码相同。因此负数的补码左移时，因空位出现在低位，则添补的代码与原码相同，即添0；右移时因空位出现在高位，则添补的代码应与反码相同，即添1。
	
	+ 逻辑移位
		左移，高位移丢，低位补0；右移，低位移丢，高位补0
	+ 循环移位
		循环移位操作特别适合将数据的低字节数据和高字节数据互换

+ 符号扩展
	+ 有时必须把采用给定位数表示的数转换成具有不同位数的某种表示形式。--如将一个8位数与一个32位数相加，要想得到正确的结果，必须先将8位数转换成32位数的形式
	+ 正数的符号扩展：原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用0进行填充。
	+ 负数的符号扩展
		+ 原码表示法：与正数相同，符号位为1
		+ 补码表示法：用1（对于整数）或0（对于小数）填充，符号位为1
		+ 反码表示法：用1填充，符号位为1
### 定点数的运算
+ 原码，反码，补码，移码
	+ 在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。
	
	+ 反码不能直接用来做运算，其结果要+1才能正常（结果是-0，也要+1，让其变为+0，这才是正确结果）
	
	+ 补码做运算时，正负符号参与运算
	
	+ 补码 = 反码 + 1，因此原码与反码均有两个0表示法，而补码只有一个，原先-0表示的，现在称为补码多出来的一个负数表示
	
	+ 移码 = 补码的符号位取反
	
	+ 移码常用来 **比较大小**，一般会把浮点数的阶码用移码表示，说的再通俗一点，把数值用移码表示出来可以一看看出他们的大小，这样很容易判断阶码的大小，移码可以 **简化浮点数的乘除法运算** 
	
	+ 原码一位乘法
		+ 由手写竖式乘法发展而来
		+ 被乘数和乘数均取绝对值参与运算，符号位为 X 异或 Y
		+ 部分积的长度同被乘数，取 **n + 1**位，以便存放乘法过程中绝对值大于等于1的值，初值为0.
		+ 从乘数的最低位y开始判断：若y=1，则部分积加上被乘数|x|，然后右移一位；若y=0，则部分积加上0，然后右移一位。
		+ 重复上一个步骤，判断n次
		+ 由于乘积的数值部分是两数绝对值相乘的结果，因此原码一位乘法运算过程中的右移操作均为逻辑右移
		+ 考虑到运算时可能出现绝对值大于1的情况（但此刻并非溢出），所以部分积和被乘数取双符号位
		
	+ 溢出概念和判别方法
		+ 溢出：运算结果超过了数的表示范围。大于机器所能表示的最大正数为上溢，小于机器所能表示的最小负数为下溢。
		+ 补码定点数加减运算溢出判断
			+ 一位符号位
				+ 参加操作的两个数符号相同，结果又与原操作数符号不同，则表示结果溢出
				+ 若符号位的进位Cs与最高数位的进位C1相同，则说明没有溢出，否则发生溢出。
			+ 双符号位 (**模4补码**)
				+ 运算结果的两个符号位S1，S2相同，表示未溢出；运算结果的两个符号位S1，S2不同，表示溢出，此时最高位符号位代表真正的符号。
				+ S1，S2 = 00：结果正数，无溢出
				+ S1，S2 = 01：结果正溢出
				+ S1，S2 = 10：结果负溢出
				+ S1，S2 = 11：结果负数，无溢出
### C语言中的整数类型及类型转换
	+ 整数类型及类型转换
		+ 不同字长整数之间的转换
			+ 当大字长变量向小字长变量强制类型转换时，系统把多余的高位字长部分直接截断，低位直接赋值，因此也是一种保持位值的处理方法。
			+ 短字长整数到长字长整数的转换，不仅要使相应的位值相等，高位部分还会扩展为原数字的符号位。
		+ 有符号数和无符号数的转换
			```c
			void	int main() {
					short x = -4321;
					unsigned short y = (unsigned short) x;
					printf("x = %d, y=%u\n", x, y);
				}
			```
			对比两者的二进制表示
	
			|变量|值|位|位|位|位|位|位|位|位|位|位|位|位|位|位|位|
			|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
			|||15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|
			|x|-4321|1|1|1|0|1|1|1|1|0|0|0|1|1|1|1|1|
			|y|61215|1|1|1|0|1|1|1|1|0|0|0|1|1|1|1|1|
	
			可知，将 **short int** 强制转换为 **unsigned short** 只改变数值，而两个变量对应的每位都是一样的。即强制类型转换的结果保持位值不变，仅改变了解释这些位的方式。
### 数据的存储和排列		
	+ 数据存储的 **大端方式** VS **小端方式**
		+ 大端方式：按从最高有效字节到最低有效字节的顺序存储数据，即最高有效字节存放在前面
		+ 小端方式：按从最低有效字节到最高有效字节的顺序存储数据，即最低有效字节存放在前面
		
	+ 数据按 **边界对齐** 方式存储
		+ 对于机器字长为32位的计算机，数据以边界对齐方式存放，半字地址一定是2的整数倍，字地址一定是4的整数倍。所存储的数据不满足上述要求时，通过填充空白字节使其符合要求。这样无论所取的数据是字节、半字还是字，均可一次访存取出，提高取指令和取数的速度。
		+ 边界对齐是一种空间换时间的思想。RISC如 **ARM** 采用边界对齐，而CISC如 **x86** 对齐和不对齐都支持，因为对齐方式取指令时间相同，因此能适应指令流水。

## 浮点数的表示与运算

+ **阶码** 控制 **小数点的位置**，**阶码每加一，整个数值增大到2倍，小数点向右移一位**，**阶码每减一，整个数值减少2倍，小数点向左移一位**

+ 15张图带你了解浮点数

  ![图片](../images/640-16531029311641.png)

  ![图片](../images/640-16531029754623.png)

  ![图片](../images/640-16531030031665.png)

  **注意上图中，阶码应该是 01111100，图片有误，但结果无误，移码表示法的01111100，其真值为-4，但是IEEE754规定，阶码E采用 `指数e的移码-1`来表示，即01111011，其真值为-3**

  ![图片](../images/640-16531032479427.png)

  ![图片](../images/640-16531033307209.png)

  ![图片](../images/640-165310338687211.png)

  ![图片](../images/640-165310353210413.png)

  ![图片](../images/640-165310355806915.png)

  ![图片](../images/640-165310356633717.png)

+ 浮点数的一般格式

  ![image-20220521102345388](../images/image-20220521102345388.png)

  ![image-20220521102406922](../images/image-20220521102406922.png)

+ 规格化浮点数

  通过调整一个 **非规格化浮点数** 的 **尾数和阶码** 的大小，使非零的浮点数在 **尾数的最高数位上保证是一个有效值**。

  + **左规**：当浮点数运算的结果为非规格化时，要进行规格化处理，**将尾数算术左移一位、阶码减一（基数为2时）** 的方法。 **可能要进行多次**。
  + **右规**：当浮点数运算的结果 **尾数出现溢出（双符号位为01或10）时，将尾数算术右移一位、阶码加一（基数为2时）** 的方法。 **需要右规时，只需进行一次**。

+ IEEE 754 标准

  ![image-20220521105658175](../images/image-20220521105658175.png)

  

  > IEEE 754标准与普通浮点数格式要求要区分开。

  **IEEE 754标准的浮点数（除临时浮点数外），是尾数用采取隐藏位策略的原码表示，且阶码用移码表示的浮点数。**

  以短浮点数为例，最高位为 **数符位**；其后是 **8位阶码**，以 **2** 为底（**即基数为2**），用 **移码** 表示，阶码的 **偏置值** 为$2^{8-1} -1=127$；其后 **23** 位是原码表示的 **尾数数值位**。对于 **规格化** 的二进制浮点数，数值的最高位总是 **1**，为了能使 **尾数多表示一位有效位，将这个“1”隐含，因此尾数数值实际上是24位。隐含的“1”是一位整数。在浮点格式中表示的23位尾数是纯小数**。例如，（12）的十进制 = （1100）的二进制，将它规格化后结果为$1.1*2^3$，其中 **整数部分的“1”将不会存储在23位尾数内**。

  + IEEE 754 浮点数格式

    | 类型                           | 数符 | 阶码 | 尾数数值 | 总位数 | （16进制）偏置值 | （10进制）偏置值 |
    | ------------------------------ | :--: | :--: | :------: | :----: | :--------------: | ---------------- |
    | 短浮点数（**单精度，float**）  |  1   |  8   |    23    |   32   |       7FH        | 127              |
    | 长浮点数（**双精度，double**） |  1   |  11  |    52    |   64   |       3FFH       | 1023             |
    | 临时浮点数                     |  1   |  15  |    64    |   80   |      3FFFH       | 16383            |

  + IEEE 754 浮点数范围

    ![image-20220521110915260](../images/image-20220521110915260.png)

+ 定点 VS 浮点

  + 数值的表示范围

    字长相同，**浮点** 所能表示的数值范围将远远大于 **定点**

  + 精度

    一个数所含有效数值位的位数。对于字长相同的定点数和浮点数来说，浮点数 **扩大了数的表示范围，但降低了精度**

  + 数的运算

    浮点数包括 **阶码** 和 **尾数** 两部分，运算时要同时做两部分的运算，而且要求运算结果 **规格化**，所以浮点运算更复杂

  + 溢出问题

    定点运算，结果 **超出数的表示范围** 时，发生溢出；

    浮点运算，结果 **超出数的表示范围却不一定溢出，只有规格化阶码超出所能表示的范围** 时，才发生溢出。
  
+ 偏置值

  以单精度浮点型float为例，指数e由 **8位二进制原码（无符号）** 表示，但这样的小数不能表示 **（-1,1）** 中的数，因为阶码总是 **正数**。所以不如 **减去一个偏置量127**，这样就能表示负的 **E** （如果没有偏置，那么 **e=E**），此时 **E=e-127**，而e的范围是 **（1，254）**，最终 **阶码E的范围为 （-126,127）**。

## 算术逻辑单元（ALU）

### 串行加法器和并行加法器

+ **运算器** 由 **算术逻辑单元（Arithmetic Logic Unit， ALU）**、**累加器**、**状态寄存器** 和 **通用寄存器** 等组成。**ALU** 的基本功能包括 **加、减、乘、除** 四则运算，**与、或、非、异或** 等逻辑运算，以及 **移位、求补** 等操作。

+ **运算器** 的操作和操作种类由 **控制器** 决定。**运算器** 处理的数据来自 **存储器**；处理后的结果数据通常送回 存储器，或暂存在 **运算器** 中。

+ **ALU** 的核心部件是 **加法器**，**加法器** = **全加器** + **其他必要的逻辑电路**。全加器 **单个或多个**， 决定加法器的 **串行和并行**。（**并行加法器的最长运算时间主要是由进位信号的传递时间决定的，每个全加器本身的求和延迟只是次要因素**）

+ 并行加法器中的每个全加器都有一个从 **低位** 送来的**进位输入**和一个传送给**高位**的 **进位输出**。通常将**传递进位信号的逻辑线路**连接起来构成的进位网络称为 **进位链**。

+ 一位全加器

  ![image-20220523115012825](../images/image-20220523115012825.png)

  + 输入
    $$
    加数 A_i、加数B_i、低位传来的进位C_{i-1}
    $$

  + 输出
    $$
    本位和S_i，向高位的进位C_i
    $$

  + 和表达式
    $$
    S_i = A_i \oplus B_i \oplus	C_{i-1}
    $$

  + 进位表达式
    $$
    C_i = A_iB_i +(A_i \oplus	B_i)C_{i-1}
    $$

    $$
    令 G_i=A_iB_i，P_i=A_i \oplus B_i，G_i是进位产生函数，P_i是进位传递函数。
    \\ G_i为1，说明有进位信号产生。
    \\ P_i为1，说明第i-1位的进位信号C_{i-1}可以通过本位向高位传送。
    $$

+ 串行加法器

  **一个全加器**，数据**逐位串行**送入加法器中进行运算，每次产生**一位和**，并且串行逐位地送回**寄存器**。**进位触发器**用来寄存**进位信号**，以便参与下一次运算。

  优点：**器件少，成本低**。缺点：**运算速度慢**

+ 并行加法器

  + 最低位产生的进位将逐位影响至最高位，因此并行加法器的最长运算时间主要是由**进位信号的传递时间决定的**

  + 提高并行加法器速度的关键是尽量**加快进位产生和传递的速度**

  + 串行进位 （**行波进位**）

    + 进位信号逐级形成
      $$
      \begin{align}
      &C_1 = A_1B_1+(A_1\oplus B_1)C_0，或C_1=G_1+P_1C_0
      \\ &C_2 = A_2B_2+(A_2 \oplus B_2)C_1，或C_2=G_2+P_2C_1
      \\ &C_n=A_nB_n+(A_n \oplus B_n)C_{n-1}，或C_n=G_n+P_nC_{n-1}
      \end{align}
      $$

  + 并行进位（**先行进位**、**同时进位**）

    + 同时形成进位信号
      $$
      \begin{align}
      & C_1=G_1+P_1C_0
      \\& C_2=G_2+P_2C_1=G_2+P_2G_1+P_2P_1C_0
      \\ &C_3=G_3+P_3C_2=G_3+P_3G_2+P_3P_2G_1+P_3P_2P_1C_0
      \end{align}
      $$

  + 分组并行进位方式

    + 把n位全加器分为若干小组，**小组内的各位之间实行并行快速进位**，**小组与小组之间可以采用串行进位方式**，也可以采用**并行快速进位**方式。

      + 单级先行进位方式（**组内并行、组间串行进位**）

        + 4位先行进位电路（**CLA**）

          以16位加法器为例，可分为4组，每组4位。第一小组组内的进位逻辑函数 $C_1、C_2、C_3、C_4$的表达式与前述相同，$C_1~C_4$信号是同时产生的

      + 多级先行进位方式（**组内并行、组间并行进位**）
      
        + 成组先行进位电路（**BCLA**）
      
          第1组内产生$G_1^*、P_1^*、C_3、C_2、C_1，不产生C_4$
      
          第2组内产生$G_2^*、P_2^*、C_7、C_6、C_5，不产生C_8$
      
          第3组内产生$G_3^*、P_3^*、C_{11}、C_{10}、C_9，不产生C_{12}$
      
          第4组内产生$G_4^*、P_4^*、C_{15}、C_{14}、C_{13}，不产生C_{16}$
      
          利用这种4位的**BCLA**电路及进位产生与传递电路和求和电路可以构成4位BCLA加法器。16位的**两级先行进位加法器**可由**4个BCLA加法器**和**1个CLA电路**构成。
      
        + 这种方法可以扩展到多于两级的先行进位加法器，如用三级先行进位结构设计64位加法器。优点是 **字长对加法时间影响甚小**，缺点是**造价较高**
  
### 算术逻辑单元的功能和结构

  + 带标志加法器

    ![image-20220523170012054](../images/image-20220523170012054.png)

    **溢出标志**的逻辑表达式为 $OF=C_n \oplus C_{n-1}$

    **符号标志**就是**和的符号**，即$SF=F_{n-1}$

    **零标志** $ZF=1当且仅当F=0$

    **进位/借位标志** $CF=C_{out} \oplus C_{in}$，即当 $C_{in}=0$ 时，CF为进位$C_{out}$，当$C_{in}=1$时，CF为进位$C_{out}$取反。

    > 为了加快加法运算的速度，实际电路一定使用多级优先进位方式。图2.19(b)是为了说明如何从加法运算结果中获得标志信息，因而使用全加器简化了加法器电路。

  + 算术逻辑单元（**ALU**）

    核心是**带标志加法器**，同时也能执行 **与，或，非** 等逻辑运算，能实现 **左移或右移** 的移位操作。

    ![image-20220523171336726](../images/image-20220523171336726.png)

    + A，B是两个n位操作数输入端
    + $C_{in}$是进位输入端
    + ALUop是操作控制端，用来决定ALU所执行的处理功能。ALUop的**位数**决定了**操作的种类**。当位数为3时，ALU最多只有8种操作。

  + 补码加减运算部件

    ![image-20220523172550058](../images/image-20220523172550058.png)

    $假设一个数的补码表示为Y，则这个数的负数的补码为\bar{Y}+1$

## 总结

+ 字 VS 字节 VS 位
  + 1位 = 1比特
  + 1字节 = 8位
  + **1字 = 2字节 （一般情况下）**
  + **1字 = 16位 （在1字 = 2字节的情况下，即常说的字长几位）**

+ 码距：同一编码中，任意两个合法编码之间不同二进制数位数的最小值 (**通过改变几位，使其变成另一个合法码字的最小改变量就是码距**)，码距**大于等于2**的数据校验码开始具有**检错**能力。**码距越大，检错、纠错能力越强**。奇偶校验码的码距等于2，可以检测出一位错误，但不能确定出错位置。海明码的码距大于2，因此不仅可以发现错误，还能指出错误的位置。

+ 常用二进制：
  $$
  2^4=16，
  2^6=64，
  2^{8}=256，
  2^{16}=65536，
  2^{32}=4294967296，
  $$

+ 校验位的计算公式，其中 **n是信息位的位数**，**k是校验位的位数**
  $$
  2^k - 1 \geq n + k
  $$

+ **奇偶校验码不能纠错**，**CRC码可以发现并纠正信息串行读/写、存储或传送中出现的一位或多位错（与多项式的选取有关）**，**海明码能发现两位错误并纠正1位错**。

+ CRC通常用于计算机网络的数据链路层，适合对大量数据的数据校验

+ 并不是每个十进制小数都可以准确的用二进制表示。例如0.3。但任意一个二进制小数都可以用十进制小数表示。

+ 关于十进制数转换为任意进制数为何采用除基取余法和乘基取整法，以及所取之数放置位置的原理，请结合R进制数的数值表示公式思考，而不应死记硬背。

+ 用移码表示浮点数的阶码有什么好处？

  + 浮点数进行加减运算时，时常要比较阶码的大小，相对于原码和补码，**移码比较大小更方便**

    > 移码是补码的符号位取反，通过取反这个动作，把负数符号位变成0，正数符号位变成1，相当于所有位都当做数值位直接进行比较即可，比原码补码用1表示负数符号位要方便很多

  + 校验移码的特殊值（**0和max**）时比较容易。阶码以移码编码时的特殊值如下。

    + 0：表示**指数为负无穷大**，相当于分数分母无穷大，整个数无穷接近0，在尾数也为0时可用来表示0；尾数不为零表示未正规化的数。
    + max：表示**指数正无穷大**，若尾数为0，则表示浮点数超出表示范围（正负无穷大）；尾数不为0，则表示浮点数运算错误。

+ 计算机中的数值数据都是二进制数吗？

  + 直接用**二进制**数表示。分为**无符号数**和**有符号数**，**有符号数**又分为**定点数**表示和**浮点数**表示
    + **无符号数**用来表示无符号整数，如**地址**
    + **定点数**用来表示**整数**
    + **浮点数**用来表示**实数**
  + 二进制编码的十进制数，一般采用**8421码**（亦称**NBCD**码），用来表示整数

+ C语言中的**int**型和**unsigned**型变量的**存储方式没有区别**，都按照**补码**的形式存储，在不溢出范围内的加减法运算也是相同的，只是**int型变量的最高位代表符号位**，而**unsigned型中的最高位表示数值位**，两者在C语言中的区别体现在输出时到底是采用**%d**还是**%u**。

+ 如何判断一个浮点数是否是规格化数？

  **为了使浮点数能尽量多地表示有效位数**，一般要求运算结果用规格化数形式表示。规格化浮点数的**尾数小数点后的第一位一定是个非零数**。

  **原码**编码的尾数，看**尾数的第一位是否为1**就行。

  **补码**表示的尾数，看**符号位和尾数最高位是否相反**。

  > IEEE 754标准的浮点数尾数用原码编码

+ 对于位数相同的定点数和浮点数，可表示的浮点数个数比定点数个数多吗？

  **不是**，可表示的数据个数取决于编码所采用的位数。编码位数一定，编码出来的数据个数就是一定的。n位编码只能表示$2^n$个数，所以对于相同位数的定点数和浮点数来说，可表示的数据个数应该一样多。（**有时可能由于一个值有两个或多个编码对应，编码个数会有少量差异**）

+ IEEE 754浮点数舍入方式

  + 就近舍入：舍入为最近可表示的数，若结果值正好落在两个可表示数的中间，则一般选择舍入结果为偶数
  + 正向舍入：朝**$+\infty$方向**舍入，即取**右边的数**
  + 负向舍入：朝**$-\infty$方向**舍入，即取**左边的数**
  + 截去：朝**0方向**舍入，即取**绝对值较小**的那个数

+ 现代计算机是否要考虑原码加减运算？

  现在计算机采用IEEE 754标准，两个浮点数加减运算时，尾数用原码的加减运算

  原码的加减运算实现方式如下两种：

  + **转换为补码**后，用**补码加减**实现，结果再**转换回原码**
  + 直接用原码进行加减运算，**符号**和**数值部分**分开进行

+ 各编码方式的数值范围（**长度为$n+1$的定点数**）

  用8421法来转二进制成十进制时，需注意 **整数部分从右边数，第n位表示为$2^{n-1}$；小数部分从左边往数，第n位表示为$2^{-n}$**
  
  | 编码方式       |     最小值编码      |   最小值    |     最大值编码      |   最大值    |            数值范围             |
  | :------------- | :-----------------: | :---------: | :-----------------: | :---------: | :-----------------------------: |
  | 无符号定点整数 | $0000 \cdots 0000$  |      0      | $1111 \cdots 1111$  | $2^{n+1}-1$ |     $0 \le x \le 2^{n+1}-1$     |
  | 无符号定点小数 | $0.000 \cdots 0000$ |      0      | $0.111 \cdots 1111$ | $1-2^{-n}$  |     $0 \le x \le 1-2^{-n}$      |
  | 原码定点整数   | $1111 \cdots 1111$  |   $1-2^n$   | $0111 \cdots 1111$  |   $2^n-1$   |     $1-2^n \le x \le 2^n-1$     |
  | 原码定点小数   | $1.111 \cdots 1111$ | $2^{1-n}-1$ | $0.111 \cdots 1111$ | $1-2^{n-1}$ | $2^{1-n}-1 \le x \le 1-2^{n-1}$ |
  | 补码定点整数   | $1000 \cdots 0000$  |   $-2^n$    | $0111 \cdots 1111$  |   $2^n-1$   |     $-2^n \le x \le 2^n-1$      |
  | 补码定点小数   | $1.000 \cdots 0001$ | $2^{1-n}-1$ | $0.111 \cdots 1111$ | $1-2^{n-1}$ | $2^{1-n}-1 \le x \le 1-2^{n-1}$ |
  | 反码定点整数   | $1000 \cdots 0000$  |   $1-2^n$   | $0111 \cdots 1111$  |   $2^n-1$   |     $1-2^n \le x \le 2^n-1$     |
  | 反码定点小数   | $1.000 \cdots 0000$ | $2^{1-n}-1$ | $0.000 \cdots 0000$ | $1-2^{n-1}$ | $2^{1-n}-1 \le x \le 1-2^{n-1}$ |
  | 移码定点整数   | $0000 \cdots 0000$  |   $-2^n$    | $1111 \cdots 1111$  |   $2^n-1$   |     $-2^n \le x \le 2^n-1$      |
  
  > 小数没有移码定义，所以上表没有移码定点小数

# 存储系统

## 存储器概述

### 存储器的分类

  + 按在计算机中的作用（层次）分类

    + 主存储器（`主存、内存`）
      + 存放**计算机运行期间所需的大量程序和数据**，CPU可以直接随机地对其进行访问，也可以和高速缓冲存储器（**Cache**）及**辅助存储器**交换数据。其特点是**容量较小、存取速度较快、每位价格较高**。

    + 辅助存储器（`辅存、外存`）
      + 主存储器的后援存储器，用来存放当前暂时不用的程序和数据，以及一些需要永久性保存的信息，它不能与CPU直接交换信息。其特点是**容量极大、存取速度较慢、单位成本低**

    + 高速缓冲存储器（`Cache`）
      + 位于主存和CPU之间，用来存放正在执行的程序段和数据，以便CPU能高速地使用它们。Cache的存取速度可与CPU的速度相匹配，但存储容量小、价格高。**现在计算机通常将它们制作在CPU中**。

  + 按存储介质分类

    + 磁表面存储器（`磁盘`、`磁带`）
    + 磁心存储器半导体存储器（`MOS型存储器`、`双级型存储器`）
    + 光存储器（`光盘`）

  + 按存取方式分类

    + 随机存储器（RAM）

      + 任何一个存储单元的内容都可以随机存取，而且存取时间与存储单元的物理位置无关。其优点是**读写方便、使用灵活**，主要用作主存或高速缓冲存储器。RAM又分为**静态RAM**和**动态RAM**

    + 只读存储器（ROM）

      + 内容只能**随机读出而不能写入**。信息一旦写入存储器就固定不变，即使断电，内容也不会丢失。因此，通常用它存放固定不变的**程序、常数和汉字字库**等。

      + 与随机存储器可共同作为主存的一部分，统一构成主存的地址域。

      + 由ROM派生出的存储器也包含可反复重写的类型，ROM和RAM的存取方式均为随机存取。

        > 注意广义上的只读存储器已可通过电擦除等方式进行写入，其“只读”的概念没有保留，但仍保留了断电内容保留、随机读取特性，但其写入速度比读取速度慢得多。

    + 串行访问存储器

      + 对存储单元进行读/写操作时，需按其物理位置的**先后顺序**寻址，包括**顺序存取**存储器（如磁带）与**直接存取**存储器（如磁盘、 光盘（**CD-ROM**））

  + 按信息的可保存性分类

    + 易失性存储器

      断电后，存储信息即消失的存储器，如**RAM**。

    + 非易失性存储器

      断电后信息仍保持的存储器，如**ROM、磁表面存储器和光存储器**。

    + 若某个存储单元所存储的信息被读出时，**原存储信息被破坏**，则称为**破坏性读出**；若读出时，被读单元原存储信息不被破坏，则称为**非破坏性读出**。具有破坏性读出性能的存储器，每次读出操作后，必须紧接一个**再生**的操作，以便恢复被破坏的信息。

### 存储器的性能指标（**存储容量、单位成本、存储速度**）

    + **存储容量 = 存储字数 * 字长**，如1M*8位。1B（Byte，字节） = 8b（bit，位）。**存储字数表示存储器的地址空间大小，字长表示一次存取操作的数据量**
    
    + 单位成本：每位价格 = 总成本 / 总容量
    
    + 存储速度：**数据传输率 = 数据的宽度 / 存储周期**
    
      + **存取时间**（$T_a$）：指从启动一次存储器操作到完成该操作所经历的时间，分为读出时间和写入时间。
      + **存取周期**（$T_m$，读写周期/访问周期）：指存储器进行一次完整的读写操作所需的全部时间，即连续两次独立访问存储器操作（**读或写操作**）之间所需的最小时间间隔。
      + **主存带宽**（$B_m$，数据传输率）：每秒从主存进出信息的最大数量，单位为**字/秒、字节/秒（B/s）或位/秒（b/s）**
    
    + **存取时间不等于存储周期，通常存储周期大于存取时间**。因为对任何一种存储器，在读写操作之后，总要有一段恢复内部状态的复原时间。对于**破坏性读出**的存储器，存取周期往往比存取时间大得多，甚至可达$T_m = 2T_a$，因此存储器中的信息读出后需要马上进行再生。
    
      ![image-20220531163128341](../images/image-20220531163128341.png)

## 存储器的层次化结构

+ 为了解决**存储系统大容量、高速度、低成本**这3个相互制约的矛盾，在计算机系统中，通常采用了多级存储器结构。

![image-20220531165519654](../images/image-20220531165519654.png)

+ 实际上，存储系统层次结构主要体现在**Cache-主存**层次和**主存-辅存**层次。前者主要解决**CPU和主存速度不匹配的问题**，后者主要解决**存储系统的容量问题**。在存储体系中，**Cache、主存能与CPU**直接交换信息，**辅存则要通过主存与CPU交换信息**；**主存与CPU、Cache、辅存**都能交换信息。
+ 主要思想：**上一层的存储器作为低一层存储器的高速缓存。**在**Cache-主存**和**主存-辅存**层次中，上一层中的内容都只是下一层中的内容的副本，也即Cache（或主存）中的内容只是主存（或辅存）中的内容的一部分。
+ **主存和Cache**之间的数据调动是由**硬件**自动完成的，对所有程序员均是透明的；而**主存和辅存**之间的数据调动则是由**硬件和操作系统**共同完成的，对应用程序员是透明的。
+ 在**主存-辅存**这一层次的不断发展中，逐渐形成了**虚拟存储系统**，在这个系统中程序员编程的地址范围与虚拟存储器的地址空间相对应。对具有虚拟存储器的计算机系统而言，编程时可用的地址空间远大于主存空间。

## 半导体随机存储器

### SRAM和DRAM

+ 通常把存放一个二进制位的物理器件称为**存储元**，是存储器的**最基本的构件**。**地址码**相同的多个**存储元**构成一个存储单元。若干**存储单元**的集合构成存储体。

+ 主存储器由**DRAM（Dynamic Random Access Memory）**实现，靠处理器的那一层（**Cache**）则由**SRAM（Static Random Access Memory）**实现，它们都属于**易失性存储器**，主要电源被切断，原来保存的信息便会丢失。**DRAM**的每比特成本低于**SRAM**。

  + SRAM只要保持通电，里面存储的数据就可以恒常保持。DRAM每隔一段时间，要刷新充电一次，否则内部的数据即会消失。
  + SRAM主要用于**二级高速缓存（Level2 Cache）**。速度快，但是集成度较低，相同容量的DRAM内存可以设计为较小体积，而SRAM需要很大体积。因此SRAM很贵。

+ SRAM的工作原理

  + 静态随机存储器（SRAM）的**存储元**是用**双稳态触发器（六晶体管MOS）**来记忆信息的，因此信息被读出后，仍保持其原状态而不需要再生（**非破坏性读出**）
  + SRAM的存取速度快，但集成度低，功耗较大，所以一般用来组成高速缓冲存储器。

+ DRAM的工作原理

  + 动态随机存储器（DRAM）是利用**存储元电路中栅极电容上的电荷**来存储信息的，DRAM的基本储存元通常只使用**一个晶体管**。所以它比SRAM的密度要高很多。DRAM采用**地址复用技术**，地址线是原来的**1/2**，地址信号分行、列两次传送。

  + 相对于SRAM来说，DRAM具有容易集成、价位低、容量大和功耗低等优点，但DRAM的存取速度比SRAM慢，一般用来组成大容量主存系统。

  + DRAM电容上的电荷一般只能维持1~2ms，因此即使电源不断电，信息也会自动消失。为此，**每隔一定时间必须刷新**，通常取2ms，称为刷新周期。常用的刷新方式有3种：

    + 集中刷新

      指在一个刷新周期内，利用一段固定的时间，依次对存储器的所有行进行逐一再生，在此期间停止对存储器的读写操作，称为**死时间**，又称访存**死区**。

      **优点**：读写操作时，不受刷新工作的影响

      **缺点**：在集中刷新期间（死区）不能访问存储器

    + 分散刷新

      把对每行的刷新分散到各个工作周期中。这样，一个存储器的系统工作周期分为**两部分**：前半部分用于正常读、写或保持；后半部分用于刷新。

      **优点**：没有死区

      **缺点**：加长了系统的存取周期，降低了整机的速度

    + 异步刷新

      前两种方法的结合，**既可缩短“死时间”，又能充分利用最大刷新间隔为2ms的特点**。具体做法是：将刷新周期除以行数，得到两次刷新操作之间的时间间隔t，利用逻辑电路每隔时间t产生一次刷新请求。这样可以**避免使CPU连续等待过长的时间，而且减少了刷新次数，从根本上提高了整机的工作效率**

  + DRAM的刷新需注意以下问题：

    + 刷新对CPU是透明的，即刷新不依赖于外部的访问
    + 动态RAM的刷新单位是行，由芯片内部自行生成行地址
    + 刷新操作类似于读操作，但又有所不同
    + 刷新时不需要选片，即整个存储器中的所有芯片同时被刷新

+ 存储器芯片的内部结构

  + 存储器芯片由**存储体**、**I/O读写电路**、**地址译码**和**控制电路**等部分组成。

    ![image-20220602082205794](../images/image-20220602082205794.png)

    + 存储体（存储矩阵）：存储单元的集合，由行选择线（X）和列选择线（Y）来选择所访问单元，存储体的相同行、列上的位同时被**读出**或**写入**
    + 地址译码器：用来将**地址**转换为**译码**输出线上的高电平，以便驱动相应的读写电路。
    + I/O控制电路：用以控制被选中的单元的**读出**或**写入**，具有放大信息的作用。
    + 片选控制信号：单个芯片容量太小，往往满足不了计算机对存储器容量的要求，因此需用**一定数量的芯片进行存储器的扩展**。在访问某个**字**时，必须**“选中”**该存储字所在的芯片，而其他芯片不被**“选中”**，因此需要有片选控制信号。
    + 读/写控制信号：根据CPU给出的是**读命令**还是**写命令**，控制被选中单元进行**读或写**。

+ 存储器的读、写周期

  + RAM的读周期

    + 读出时间（$t_A$）：从**给出有效地址**开始，到**读出所选中单元的内容并在外部数据总线上稳定地出现**所需的时间。

    + 地址片选信号$\rm \overline{CS}$必须保持到数据稳定输出，$t_{CO}$为片选的保持时间，在读周期中$\rm \overline{WE}$为高电平。

    + **读周期**与**读出时间**是两个不同的概念，**读周期时间**（$t_{RC}$）表示存储芯片进行两次连续读操作时所必须间隔的时间，它**总是大于等于读出时间**。

      ![image-20220602083740775](../images/image-20220602083740775.png)

  + RAM的写周期

    + 要实现**写操作**，要求片选信号$\rm \overline{CS}$和写命令信号$\rm \overline{WE}$都必须为低电平。为使数据总线上的信息能够可靠地写入存储器，要求$\rm \overline{CS}$信号与$\rm \overline{WE}$信号相“与”的宽度至少为$t_W$。

    + 为了保证在地址变化期间，不会发生错误写入而破坏存储器的内容，$\rm \overline{WE}$信号在地址变化期间必须为**高电平**。为了保证有效数据的可靠写入，地址有效地时间至少应为**$t_{WC}=t_{AW}+t_W+t_{WR}$**。

    + 为了保证在$\rm \overline{WE}$和$\rm \overline{CS}$变为无效前能把数据可靠地写入，要求写入的数据必须在$t_{DW}$以前在数据总线上已经稳定。

      ![image-20220602084537627](../images/image-20220602084537627.png)

  + SRAM和DRAM的比较

    | 类型/特点      |   SRAM   |   DRAM   |
    | -------------- | :------: | :------: |
    | 存储信息       |  触发器  |   电容   |
    | 破坏性读出     |    非    |    是    |
    | 需要刷新       |   不要   |   需要   |
    | 送行列地址     |  同时送  | 分两次送 |
    | 运行速度       |    块    |    慢    |
    | 集成度         |    低    |    高    |
    | 发热量（功耗） |    大    |    小    |
    | 存储成本       |    高    |    低    |
    | 主要用途       | 高速缓存 | 主机内存 |

### 只读存储器（`ROM`）

  + 特点

    + ROM和RAM都是支持随机存取的存储器，其中SRAM和DRAM均为易失性半导体存储器。而ROM中一旦有了信息，就不能轻易改变，即使掉电也不会丢失，它在计算机系统中是只供读出的存储器。ROM器件有两个显著的优点。
      + **结构简单**，所以位密度比可读写存储器的高
      + **具有易失性**，所以可靠性高

  + 类型

    + 根据**制造工艺**不同，ROM可分为**掩模式只读存储器（MROM，Mask Read-Only Memory）**、**一次可编程只读存储器（PROM，Programmable Read-Only Memory）**、**可擦除可编程只读存储器（EPROM，Erasable Programmable Read-Only Memory）**、**闪速存储器（Flash Memory）**和**固态硬盘（Solid State Drives）**。

      + 掩模式只读存储器

        MROM的内容由半导体制造厂按用户提出的要求，在芯片的生产过程中直接写入，写入以后任何人都无法改变其内容。优点是**可靠性高，集成度高，价格便宜**；缺点是**灵活性差**

      + 一次可编程只读存储器

        PROM是可以实现一次性编程的只读存储器，允许用户利用专门的设备（编程器）写入自己的程序，一旦写入，内容就无法改变。

      + 可擦除可编程只读存储器

        EPROM不仅可以由用户利用编程器写入信息，而且可以对其内容进行多次改写。需要**修改**EPROM的内容时，先将其全部内容擦除，然后编程。EPROM又分为两种，即**紫外线擦除（UVEPROM）**和**电擦除（$\rm{E^2PROM}$）**。EPROM虽然既可读又可写，但它不能取代RAM，因为EPROM的编程次数有限，且写入时间过长。

      + 闪速存储器（Flash Memory）

        Flash Memory是在EPROM与$\rm{E^2PROM}$的基础上发展起来的，其主要特点是既可**在不加电的情况下长期保存信息**，又能**在线进行快速擦除与重写**。闪速存储器既有EPROM的价格便宜、集成度高的优点，又有$\rm{E^2PROM}$电可擦除重写的特点，且擦除重写的速度快。

      + 固态硬盘（Solid State Drives，SSD）

        基于闪存的固态硬盘是用**固态电子存储芯片阵列**制成的硬盘，由控制单元和存储单元（FLASH芯片）组成。保留了Flash Memory**长期保存信息、快速擦除与重写**的特性。对比传统硬盘也具有**读写速度快、低功耗**的特性，缺点是**价格较高**。

### 主存储器的基本组成

  + 如下为**主存储器（Main Memory，MM）**的基本组成框图，其中由一个个存储0或1的**记忆单元**（也称**存储元件**）构成的**存储矩阵**（也称**存储体**）是存储器的**核心部分**。

    ![image-20220602104757117](../images/image-20220602104757117.png)

  + **记忆单元**是具有两种稳态的能表示二进制0和1的物理器件。为了存取存储体中的信息，必须对**存储单元**编号（也称**编址**）。**编址单位**是指具有相同地址的那些存储元件构成的一个单位，可以按字节编址，也可以按字编址。**现代计算机通常采用字节编址方式，此时存储体内的一个地址中有1字节**。

  + **指令执行过程**中需要访问**主存**时，CPU首先把**被访问单元的地址**送到**MAR**（Memory Address Register，地址寄存器）中，然后通过**地址线**将**主存地址**送到**主存中的地址寄存器**，以便**地址译码器**进行**译码**选中相应单元，同时CPU将**读写信号**通过**控制线**送到主存的**读写控制电路**。

  + 如果是**写操作**，那么CPU同时将要写的信息送到**MDR**（Memory Data Register，主存数据寄存器）中，在**读写控制电路**的控制下，经**数据线**将信号写入选中的单元；如果是**读操作**，那么主存读出选中单元的内容送到**数据线**，然后送到**MDR**中。

  + 如果是**读操作**，那么主存读出选中单元的内容送到**数据线**，然后送到**MDR**中。**数据线的宽度与MDR的宽度相同**，**地址线的宽度与MAR的宽度相同**。

  + 下图采用**64位**数据线，所以在按字节编址方式下，每次最多可以存取8个单元的内容。**地址线的位数决定了主存地址空间的最大可寻址范围**。例如，36位地址的最大寻址范围为$ 0\sim 2^{36}-1$，即地址从0开始编号。

    ![image-20220602111531355](../images/image-20220602111531355.png)

    **数据线数和地址线数共同反映存储体容量的大小**。上图芯片的容量=$2^{36}*64$位。

## 主存储器与CPU的连接

### 连接原理

+ 主存储器通过**数据总线**、**地址总线**和**控制总线**与CPU连接

+ **数据总线**的位数与**工作频率**的乘积正比于**数据传输率**

+ **地址总线**的位数决定了可寻址的最大内存空间

+ **控制总线（读/写）**指出总线周期的类型和本次输入/输出操作完成的时刻

  ![image-20220606080704221](../images/image-20220606080704221.png)

### 主存容量的扩展

由于单个存储芯片的容量是有限的，它在字数或字长方面与实际存储器的要求都有差距，因此需要在**字**和**位**两方面进行扩充才能满足实际存储器的容量要求。通常采用**位扩展法**、**字扩展法**和**字位同时扩展法**来扩展主存容量。

+ `位扩展法`

  + CPU的**数据线数**与存储芯片的**数据位数**不一定相等，此时必须对存储芯片扩位（即进行**位扩展**，用多个存储器件对**字长**进行扩充，**增加存储字长**），使其**数据位数**与CPU的**数据线数**相等。

  + **位扩展**的连接方式是将多个存储芯片的**地址端**、**片选端**和**读写控制端**相应并联，**数据端**分别引出。

  + 如下所示，用8片 **8K*1位**的RAM芯片组成**8K*8位**的存储器。8片RAM芯片的地址线$A_{12} \sim A_0、\overline{CS}、\overline{WE}$都分别连在一起，每片的**数据线**依次作为**CPU数据线**的一位。

    ![image-20220606082123288](../images/image-20220606082123288.png)

    > 仅采用位扩展时，各芯片连接**地址线**的方式**相同**，但连接**数据线**的方式**不同**，在某一个时刻选中所有的芯片，所以片选信号 $\rm \overline{CS}$要连接到所有芯片。

+ `字扩展法`

  + 增加存储器中的**字的数量**，而**位数不变**。字扩展将芯片的**地址线**、**数据线**、**读写控制线**相应并联，而由片选信号来区分各芯片的地址范围。

  + 如下所示，用4片**16K*8位**的RAM芯片组成**64K*8位**的存储器。4片RAM芯片的数据线$D_0 \sim D_7和\overline{WE}$都分别连在一起。将$A_{15}A_{14}$用作片选信号，$A_{15}A_{14}=00$时，译码器输出端0有效，选中最左边的1号芯片；$A_{15}A_{14}=01$时，译码器输出端1有效，选中2号芯片，以此类推（**在同一时间只能有一个芯片被选中**）。各芯片的地址分配如下

    + 第1片，最低地址：**00**00 0000 0000 0000；最高地址：**00**00 0000 0000 0000 0000 （**16位**）

    + 第2片，最低地址：**01**00 0000 0000 0000；最高地址：**01**00 0000 0000 0000

    + 第3片，最低地址：**10**00 0000 0000 0000；最高地址：**10**00 0000 0000 0000

    + 第4片，最低地址：**11**00 0000 0000 0000；最高地址：**11**11 1111 1111 1111

      > 仅采用**字扩展**时，各芯片连接**地址线**的方式**相同**，连接**数据线**的方式也**相同**，但在某一时刻只需选中部分芯片，所以通过**片选信号$\rm \overline{CS}$或**采用**译码器**设计连接到相应的芯片。

      ![image-20220606083311441](../images/image-20220606083311441.png)

+ `字位同时扩展法`

  + 如下图所示，用8片**16K*4位**的RAM芯片组成**64K*8位**的存储器。每两片构成一组**16K*8位**的存储器（**位扩展**），4组便构成**64K*8位**的存储器（**字扩展**）。地址线$A_{15}A_{14}$经译码器得到4个片选信号，$A_{15}A_{14}=00$时，输出端0有效，选中第一组的芯片（**①和 ②**）；$A_{15}A_{14}=01$时，输出端1有效，选中第二组芯片（ **③ 和④**），以此类推。

    ![image-20220607081331636](../images/image-20220607081331636.png)

    > 采用**字位同时扩展**时，各芯片连接**地址线**的方式**相同**，但连接**数据线**的方式**不同**，而且需要通过**片选信号$\rm \overline{CS}$**或采用**译码器**设计连接到相应的芯片

### 存储芯片的地址分配和片选

+ CPU要实现对存储单元的访问，首先要选择存储芯片，即进行**片选**；然后为选中的芯片依**地址码**选择相应的存储单元，以进行数据的存取，即进行**字选**。片内的**字选**通常是由CPU送出的**N条低位地址线**完成的，地址线直接接到所有存储芯片的地址输入端（N由片内存储容量$2^N$决定）。**片选信号**的产生分为**线选法**和**译码片选法**

  + `线选法`

    + 用除**片内寻址**外的高位地址线直接（或经反相器）分别接到各个存储芯片的**片选端**，当某地址线信息为**“0”**时，就选中与之对应的存储芯片。这些片选地址线每次寻址时**只能有一位有效**，不允许同时有多位有效，这样才能保证**每次只选中一个芯片**（或芯片组）。

    + 假设4片**2K*8位**的存储芯片用线选法构成**8K*8位**存储器，各芯片的片选信号如下，其中低位地址线$A_{10} \sim A_0$作为字选线，用于片内寻址。

      ![image-20220607082515151](../images/image-20220607082515151.png)

    + 优点是：**不需要地址译码器，线路简单**

    + 缺点是：**地址空间不连续，选片的地址线必须分时为低电平（否则不能工作），不能充分利用系统的存储器空间，造成地址资源的浪费**

  + `译码片选法`

    + 译码片选法用除**片内寻址**外的高位地址线通过**地址译码器**芯片产生片选信号。如用8片**8K*8位**的存储芯片组成**64K*8位**存储器（地址线16位，数据线8位），需要8个片选信号；若采用**线选法**，除去片内寻址的13位地址线，仅余高3位，不足以产生8个片选信号。因此，采用**译码片选法**，即用一片74LS38作为地址译码器，则$A_{15}A_{14}A_{13}=000$时选中第一片，$A_{15}A_{14}A_{13}=001$时选中第二片，以此类推（即3位二进制编码）

### 存储器与CPU的连接

+ **合理选择存储芯片**

  要组成一个主存系统，选择存储芯片是第一步，主要指存储芯片的类型（RAM或ROM）和数量的选择。通常选用**ROM**存放**系统程序**、**标准子程序**和**各类常数**，**RAM**则是为**用户编程**而设置的。此外，在考虑芯片数量时，要尽量使连线简单、方便

+ **地址线的连接**

  存储芯片的容量不同，地址线数也不同，而CPU的地址线数往往比存储芯片的地址线数要多。通常将**CPU地址线的低位与存储芯片的地址线**相连，以选择芯片中的某一单元（**字选**），这部分的译码是由芯片的片内逻辑完成的。而**CPU地址线的高位则在扩充存储芯片时使用**，用来选择存储芯片（**片选**），这部分译码由**外接译码器**逻辑完成。

+ **数据线的连接**

  **CPU**的数据线数与**存储芯片**的数据线数不一定相等，在相等时可直接相连；在不等时必须对**存储芯片扩位**，使其**数据位数**与CPU的**数据线数**相等。

+ **读/写命令线的连接**

  CPU读/写命令线一般可直接与存储芯片的读/写控制端相连，通常**高电平**为读，**低电平**为写。有些CPU的读/写命令线是分开的（读为$\rm \overline{RD}$，写为$\rm \overline{WE}$，均为**低电平有效**），此时CPU的**读命令线**应与存储芯片的允许读控制端相连，而CPU的**写命令线**则应与存储芯片的允许写控制端相连。

+ **片选线的连接**

  + 片选线的连接是CPU与存储芯片连接的关键。存储器由许多存储芯片叠加而成，哪一片被**选中**完全取决于该存储芯片的**片选控制端$\rm \overline{CS}$**是否能接受到来自CPU的**片选有效信号**。
  + 片选有效信号与CPU的访存控制信号**$\rm \overline{MREQ}$（低电平有效）**有关，因为只有当CPU要求访存时，才要求选中存储芯片。若CPU访问I/O，则$\rm \overline{MREQ}$为高，表示不要求存储器工作。

## 双端口RAM和多模块存储器

为了**提高CPU访问存储器的速度**，可以采用**双端口存储器**、**多模块存储器**等技术，它们同属**并行技术**，前者为**空间并行**，后者为**时间并行**。

### 双端口RAM

+ 指同一存储器有左、右两个独立的端口，分别具有两组相互独立的**地址线**、**数据线**和**读写控制线**，允许两个独立的**控制器**同时异步地访问存储单元。

+ 如下图，当两个端口的地址不相同时，在两个端口上进行读写操作一定不会发生冲突

  ![image-20220607155313163](../images/image-20220607155313163.png)

+ 两个端口**同时存取**存储器的**同一地址单元**时，会因数据冲突造成数据**存储或读取错误**。两个端口对同一主存操作有以下4种情况

  + 两个端口不同时对同一地址单元存取数据
  + 两个端口同时对同一地址单元读出数据
  + 两个端口同时对同一地址单元写入数据（**会出现写入错误**）
  + 两个端口同时对同一地址单元操作，一个写入数据，一个读出数据（**会出现读出错误**）

  解决方法：置**“忙”信号$\rm \overline{BUSY}$**为0，由判断逻辑决定**暂时关闭一个端口**（即被延时），未被关闭的端口正常访问，被关闭的端口延长一个很短的时间段后再访问。

### 多模块存储器

为**提高访存速度**，常采用**多模块存储器**，常用的有**单体多字存储器**和**多体低位交叉存储器**。

> CPU的速度比存储器的快，若同时从存储器中取出n条指令，就可充分利用CPU资源，提高运行速度。**多体交叉存储器**就是基于这种思想提出的。

+ `单体多字存储器`

  + 单体多字系统的特点是**存储器中只有一个存储体**，每个存储单元存储m个字，总线宽度也为m个字。一次并行读出m个字，**地址必须顺序排列**并**处于同一存储单元**。
  + 单体多字系统在一个存取周期内，从同一地址取出m条指令，然后将指令逐条送至CPU执行，即每隔1/m存取周期，CPU向主存取一条指令。显然，这**增大了存储器的带宽，提高了单体存储器的工作速度。**
  + 缺点是：**指令和数据在主存内必须是连续存放的，一旦遇到转移指令，或操作数不能连续存放，这种方法的效果就不明显**

+ `多体并行存储器`

  + 多体并行存储器由**多体模块**组成。每个模块都有相同的容量和存取速度，各模块都有独立的**读写控制电路**、**地址寄存器**和**数据寄存器**。它们既能并行工作，又能交叉工作。

  + 多体并存存储器分为**高位交叉编址（顺序方式）**和**低位交叉编址（交叉方式）**两种

    + `高位交叉编址`：**高位地址表示体号，低位地址为体内地址**。如下图，存储器共有4个模块$M_0 \sim M_3$，每个模块有n个单元，各模块的地址范围如下图。

      ![image-20220607165842865](../images/image-20220607165842865.png)

      高位交叉编址方式下，总是把**低位的体内地址**送到由**高位体号确定的模块**内进行译码。访问一个连续主存块时，总是先在一个模块内访问，等到该模块访问完才转到下一个模块访问，**CPU总是按顺序访问存储模块，存储模块不能被并行访问，因而不能提高存储器的吞吐率**。

      > 模块内的地址是连续的，存取方式仍是**串行存取**，因此这种存储器仍是顺序存储器。

    + `低位交叉编址`：**低位地址为体号，高位地址为体内地址**。如下图，每个模块按**“模m”**交叉编址，**模块号=单元地址%m**，假定有m个模块，每个模块有k个单元，则0，m，···，(k-1)m单元位于$M_0$；第1，m+1，···，(k-1)m+1单元位于$M_1$；以此类推。

      ![image-20220607170601157](../images/image-20220607170601157.png)

      低位交叉编址方式下，总是把**高位的体内地址**送到由**低位体号确定的模块**内进行译码。程序连续存放在相邻模块中，因此称采用此编址方式的存储器为交叉存储器。采用低位交叉编址后，可在不改变每个模块存取周期的前提下，采用**流水线的方式并行存取**，提高存储器的带宽。

      设**模块字长**等于**数据总线宽度**，模块**存取一个字的存取周期为T**，**总线传送周期为r**，为实现流水线方式存取，存储器**交叉模块数**应大于等于
      $$
      m=T/r
      $$
      式中，**m称为交叉存取度**。

      每经过r时间延迟后，启动下一个模块，交叉存储器要求其模块数必须大于等于m，以保证启动某模块后经过**m*r**的时间后再次启动该模块时，其**上次的存取操作已经完成**（即**流水线不间断**）。这样，**连续存取m个字所需的时间为**
      $$
      t_1=T+(m-1)r
      $$
      而顺序方式连续读取m个字所需时间为**$t_2=mT$**。可见低位交叉存储器的带宽大大提高。模块数为4的流水线方式存取示意图如下

      ![image-20220607171840942](../images/image-20220607171840942.png)

      

## 高速缓冲存储器

由于程序的转移概率不会很低，数据分布的离散性较大，所以单纯依靠**并行主存系统**提高主存系统的频宽是有限的。这就必须从系统结构上进行改进，即采用**存储体系**。通常将存储系统分为**“Cache-主存”层次**和**“主存-辅存”层次**。

### 程序访问的局部性原理

+ `时间局部性`
  + 在最近的未来要用到的信息，很可能是现在正在使用的信息，因为程序中存在循环。
+ `空间局部性`
  + 在最近的未来要用到的信息，很可能与现在正在使用的信息在**存储空间上是邻近的**，因为指令通常是顺序存放的、顺序执行的，数据一般也是以向量、数组等形式簇聚地存储在一起的。
+ **高速缓冲技术**就是利用**程序访问的局部性原理**，把程序中**正在使用的部分**存放在一个高速的、容量较小的Cache中，使CPU的访存操作**大多数针对Cache进行**，从而大大提高程序的执行速度。

### Cache的基本工作原理

+ Cache位于存储器层次结构的**顶层**，通常由**SRAM**构成，其基本结构如下

  ![image-20220608084346384](../images/image-20220608084346384.png)

+ 为便于**Cache和主存之间交换信息**，Cache和主存都被划分为**相等的块**，**Cache块**又称为**Cache行**，每块由若干字节组成，块的长度称为**块长**（**Cache行长**）。由于Cache的容量远小于主存的容量，所以Cache中的块数要远少于主存中的块数，它仅保存主存中最活跃的若干块的副本。因此Cache按照某种策略，预测CPU在未来一段时间内欲访存的数据，将其装入Cache。

+ 当CPU发出**读**请求时，若访存地址在Cache中**命中**，就将此地址**转换**成Cache的地址，直接对Cache进行**读**操作，**与主存无关**；若Cache**不命中**，则仍需**访问主存**，并把此**字**所在的**块**一次性地从**主存**调入**Cache**。若此时**Cache已满**，则需根据某种**替换算法**，用这个**块**替换**Cache**中**原来的某块**信息。

  > **CPU**与**Cache**之间的数据交换以**字**为单位，而**Cache**与**主存**之间的数据交换则以**Cache块**为单位。

+ 当CPU发出**写**请求时，若Cache**命中**，有可能会遇到**Cache**与**主存**中的**内容不一致**的问题。所以若Cache**命中**，需要按照一定的**写策略**处理，常见的有**全写法**和**写回法**

+ **CPU欲访问的信息已在Cache中的比率**称为**Cache的命中率**。设一个程序执行期间，**Cache的总命中次数为$N_c$**，**访问主存的总次数为$N_m$**，则命中率H为
  $$
  H=N_c/(N_c+N_m)
  $$
  可见，为**提高访问效率**，命中率H越接近1越好。设**$t_c$为命中时的Cache访问时间**，**$t_m$为未命中时的访问时间**，**1-H表示未命中率**，则**Cache-主存系统的平均访问时间$T_a$**为
  $$
  T_a=Ht_c+(1-H)t_m
  $$

### **Cache**和**主存**的映射方式

+ Cache行中的信息是**主存**中某个块的副本，**地址映射**是指把**主存地址空间**映射到**Cache地址空间**，即把存放在**主存**中的信息按照某种规则装入**Cache**。

+ 由于**Cache行数**比**主存块数**少得多，因此主存中只有一部分块的信息可放在Cache中，因此在Cache中要为每**块**加一个标记，指明它是**主存**中哪一块的副本。该标记的内容相当于主存中块的编号。

+ 为了说明**Cache行**中的信息是否**有效**，每个Cache行需要一个**有效位**。

+ 地址映射的方法共**3**种

  + `直接映射`

    + 主存中的每一块只能装入Cache中的唯一位置。若这个位置已有内容，则产生**块冲突**，原来的块将无条件地被替换出去（**无须使用替换算法**）。直接映射实现简单，但不够灵活，即使Cache的其他许多地址空着也不能占用，这使得直接映射的**块冲突概率**最高，**空间利用率**最低。

    + 直接映射的关系可定义为
      $$
      j=i \mod 2^c
      $$

      + **j**是Cache的块号，即Cache行号

      + **i**是主存的块号

      + **$2^c$**是Cache中的总块数

      + 主存块号的**低c位**正好是它要装入的Cache行号。给每个Cache行设置一个长为**t=m-c**的**标记**（tag），当主存某块调入Cache后，就将其块号的**高t位**设置在对应Cache行的**标记**中

      + 直接映射的地址结构为

        ![image-20220610144257324](../images/image-20220610144257324.png)

      + CPU访存过程如下图
        + 根据访存地址中间的**c位**，找到对应的**Cache行**
        + 将对应**Cache行**中的**标记**和**主存地址**的**高t位标记**进行比较
          + 若**相等**且**有效位为1**，则访问Cache**命中**，此时根据主存地址中低位的**块内地址**，在对应的Cache行中存取信息
          + 若**不相等**或**有效位为0**，则**不命中**，此时CPU从主存中读出该地址所在的一块信息送到对应的Cache行中，将**有效位**置**1**，并将**标记**设置为地址中的**高t位**，同时将该地址中的内容**送CPU**

      ![image-20220610144341114](../images/image-20220610144341114.png)

  + `全相联映射`

    + 主存中的**每一块**可以装入Cache中的**任何位置**，每行的**标记**用于指出该行取自主存的哪一块，所以CPU访存时，需要与**所有**Cache行的标记进行比较。
    + 优点：**比较灵活，Cache块的冲突概率低，空间利用率高，命中率也高**
    + 缺点：**标记的比较速度较慢，实现成本较高**，通常需采用昂贵的按内容寻址的相联存储器进行地址映射。

    ![image-20220610150237627](../images/image-20220610150237627.png)

    + 全相联映射的地址结构

      ![image-20220610150306610](../images/image-20220610150306610.png)

  + `组相联映射`

    + 将Cache空间分成**大小相同**的组，主存的一个数据块可以装入一组内的**任何**一个位置，即**组间**采取**直接映射**，而**组内**采取**全相联映射**

    + 是**直接映射**和**全相联映射**的一种折中，当**Q=1**时变为**全相联映射**，当**Q=Cache块数**时变为**直接映射**。

    + 假设每组有**r**个Cache行，则称之为**r路组相联**

    + 组相联映射的关系可定义为
      $$
      j=i \mod Q
      $$

      + **j**是Cache行的组号
      + **i**是主存的块号
      + **Q**是Cache的组数

    + **路数**越大，即每组Cache行的数量越大，发生块冲突的概率越低，但相联比较电路也越复杂。选定适当的数量，可使**组相联映射**的成本接近**直接映射**，而**性能**上仍接近**全相联映射**。

    + 组相联映射的地址结构

      ![image-20220610155400765](../images/image-20220610155400765.png)

    + CPU访存过程

      + 根据访存地址中间的**组号**找到对应的**Cache组**

      + 将对应Cache组中每个行的**标记**与主存地址的**高位标记**进行比较

        + 若有**一个相等**且**有效位为1**，则访问Cache**命中**。此时根据主存地址中的**块内地址**，在对应Cache行中存取信息

        + 若**都不相等**或虽**相等**但**有效位为0**，则**不命中**，此时CPU从主存中读出该地址所在的一块信息送到对应Cache组的**任意一个空闲行**中，将**有效位**置**1**，并**设置标记**，同时将该地址中的内容送CPU

          ![image-20220610160127860](../images/image-20220610160127860.png)

### Cache中主存块的替换算法

+ 采用**全相联映射**或**组相联映射**方式时，从**主存**向**Cache**传送一个新块，当**Cache**或**Cache组**中的空间已被占满时，就需要使用替换算法置换Cache行。 

+ 采用**直接映射**时，一个给定的主存块只能放到唯一的固定Cache行中，所以在对应Cache行已有一个主存块的情况下，新的主存块毫无选择地把原先已有的那个主存块替换掉，因而**无须考虑**替换算法。

+ 常用的替换算法有**随机算法（RAND）**、**先进先出算法（FIFO）**、**近期最少使用算法（LRU）**和**最不经常使用算法（LFU，考查最多的算法）**
  + `随机算法`
    
    + **随机地确定**替换的Cache块，实现比较简单，但**未**依据程序访问的**局部性原理**，因此**可能命中率较低**
    
  + `先进先出算法`
    
    + 选择**最早调入**的行进行替换。实现比较容易，但**未**依据程序访问的**局部性原理**，因为最早进入的主存块也可能是目前经常要用到的
    
  + `近期最少使用算法`
    + 依据程序访问的**局部性原理**，选择**近期内长久未访问过的Cache行**作为替换的行，平均命中率要比**FIFO**的高，是**堆桟类算法**
    
    + LRU算法对每个Cache行设置一个**计数器**，用**计数值**来记录主存块的使用情况，并根据计数值选择淘汰某个块，计数值的**位数**与Cache组**大小**有关，**2**路时有**1**位LRU位，**4**位时有**2**位LRU位。
    
    + 采用**4路**组相联，有**5**个主存块｛1,2,3,4,5｝映射到Cache的同一组，对于主存访问序列**｛1,2,3,4,1,2,5,1,2,3,4,5｝**，采用**LRU**算法的替换过程如下。
    
      + **左**边数字对应**Cache行的计数值**
    
      + **右**边数字是**存放在该行中的主存块号**。
    
        ![image-20220613082858297](../images/image-20220613082858297.png)
    
      + 计数器规则
    
        + **命中**时，所命中的行的**计数器清零**，比其低的计数器**加1**，其余不变
        + **未命中**且**还有空闲行**时，新装入的行的计数器**置0**，其余**全加1**
        + **未命中**且**无空闲行**时，计数值为**3**的行的信息块被**淘汰**，新装行的块的计数器**置0**，其余**全加1**。
    
      + `抖动`
    
        + 当集中访问的存储区超过Cache组的大小时，命中率可能变得很低，如上图的访问序列为｛1,2,3,4,5,1,2,3,4,5,1...｝时，而Cache每组只有4行，那么命中率为0，这种现象称为**抖动**
    
  + `最不经常使用算法`
  
    + **将一段时间内被访问次数最少的存储行换出**。每行也设置一个计数器，新行建立后从**0**开始计数，每访问一次，被访问的行计数器加**1**，需要替换时比较**各特定行的计数值**，将计数值**最小**的行换出。
    + 这种算法与**LRU**类似，但不完全相同。

### Cache写策略

+ 因为Cache中的内容是**主存块副本**，当对Cache中的内容进行更新时，就需选用**写操作策略**使**Cache**内容和**主存**内容保持一致。此时分两种情况

  + `全写法`（**写直通法，Write-Through**）

    + 当CPU对Cache写命中时，必须把数据**同时**写入**Cache**和**主存**。当某一块需要**替换**时，不必把这一块写回主存，用新调入的块**直接覆盖**即可

    + 这种方法**实现简单**，能**随时保持主存数据的正确性**。缺点是**增加了访存次数，降低了Cache的效率**

    + **写缓冲**：为减少**全写法**直接写入主存的时间损耗，在Cache和主存之间加一个**写缓冲**（Write Buffer），如下图，CPU**同时**写数据到**Cache**和**写缓冲**中，**写缓冲**再控制将内容写入主存。**写缓冲**是一个**FIFO**队列，可以解决**速度不匹配**的问题。但若出现频繁写时，会使**写缓冲饱和溢出**。

      ![image-20220613084446199](../images/image-20220613084446199.png)

  + `写回法`（**Write-Back**）
    + 当CPU对Cache写命中时，**只修改Cache**的内容，而**不立即写入主存**，只有当此块被换出时才写回主存。
    + 这种方法**减少了访存次数**，但存在**不一致**的隐患。采用这种策略时，每个Cache行必须设置一个标志位（**脏位**），以反映**此块是否被CPU修改过**

+ **全写法**和**写回法**都对应于**Cache写命中**（要被修改的单元在Cache中）时的情况。对于**Cache写不命中**，有以下两种处理方法

  + `写分配法`
    + 加载主存中的块到Cache中，然后更新这个Cache块。它试图利用程序的**空间局部性**，但缺点是**每次不命中都需要从主存中读取一块**
  + `非写分配法`
    + 只**写入主存**，不进行调块

+ **非写分配法**通常与**全写法**合用，**写分配法**通常和**写回法**合用

+ 现代计算机的Cache通常设立多级Cache（**通常是3级**），假定设3级Cache，按离CPU的**远近**可各自命名为**L1 Cache**、**L2 Cache**、**L3 Cache**，离CPU越远，访问速度越慢，容量越大。指令Cache与数据Cache分离一般在L1级，此时通常为**写分配法**与**写回法**合用。

  + 如下图是含有**两级**Cache的系统，**L1 Cache**对**L2 Cache**使用全写法，**L2 Cache**对主存使用写回法，由于**L2 Cache**存在，其访问速度大于**主存**，因此避免了**因频繁写时造成的写缓冲饱和溢出**。	

    ![image-20220613155203351](../images/image-20220613155203351.png)

## 虚拟存储器

**主存**和联机工作的**辅存**共同构成了虚拟存储器，二者在硬件和系统软件的共同管理下工作。对于**应用程序员**而言，虚拟存储器是**透明**的。虚拟存储器具有**主存的速度**和**辅存的容量**，提高了存储系统的性价比。

### 虚拟存储器的概念

+ 虚拟存储器将**主存**或**辅存**的地址空间统一编址，形成一个庞大的地址空间，在这个空间内，用户可以自由编程，而不必在乎实际的主存容量和程序在主存中实际的存放位置。

+ 用户编程允许涉及的地址称为**虚地址**或**逻辑地址**，**虚地址**对应的存储空间称为**虚拟空间**或**程序空间**。实际的主存单元地址称为**实地址**或**物理地址**，**实地址**对应的是主存地址空间，也称**实地址空间**。

  ![image-20220614093304872](../images/image-20220614093304872.png)

+ **虚地址**比**实地址**要大很多

+ CPU使用**虚地址**时，由辅助硬件找出**虚地址**和**实地址**之间的对应关系，并判断这个虚地址对应的存储单元内容是否已装入主存。

  + 若**已在主存**中，则通过**地址变换**，CPU可直接访问主存指示的实际单元
  + 若**不在主存**中，则把包含这个字的**一页**或**一段**调入**主存**后再由CPU访问
  + 若**主存已满**，则采用**替换算法**置换主存中的一页或一段

+ 实际的物理存储层次上，所编程序和数据在操作系统管理下，先送入**磁盘**，然后操作系统将当前运行所需要的部分调入**主存**，供CPU使用，其余暂不运行的部分则留在磁盘中。

  ### 页式虚拟存储器

  + 以**页**为基本单位的虚拟存储器

  + **虚拟空间**和**主存空间**都被划分成同样大小的**页**，主存的页称为**实页**，虚存的页称为**虚页**。把虚拟地址分为两个字段：**虚页号**和**业内地址**。**虚拟地址**到**物理地址**的转换是由**页表**实现的。**页表**是一张存放在**主存**中的**虚页号**和**实页号**的对照表，它记录程序的虚页调入主存时被安排在主页中的位置。页表一般长久地保存在内存中。

  + `页表`

    + **有效位**也称**装入位**，用来表示对应页面是否在主存

      + 若为**1**，则表示该虚拟页已从**外存**调入**主存**，此时**页表项**存放该页的物理页号
      + 若为**0**，则表示没有调入主存，此时页表项**可以存放**该页的磁盘地址

    + **脏位**也称**修改位**，用来表示页面是否被**修改**过

    + 虚拟机制中采用**回写策略**，利用**脏位**可判断替换时是否需要写回磁盘

    + **引用位**也称**使用位**，用来配合**替换策略**进行设置，例如是否**实现最先调入（FIFO位）**或**最近最少用（LRU位）**策略等。

      ![image-20220614095038797](../images/image-20220614095038797.png)

    + CPU执行指令时，需要先将**虚拟地址**转为**主存物理地址**。每个进程都有一个**页表基址寄存器**，存放该进程的页表首地址，然后根据虚拟地址**高位**部分的**虚拟页号**找到对应的页表项

      + 若装入位为1，则取出物理页号，和虚拟地址**低位**部分的页内地址拼接，形成实际物理地址

      + 若装入位为0，则说明**缺页**，需要操作系统进行缺页处理。如下为**地址变换过程**

        ![image-20220614095354529](../images/image-20220614095354529.png)

    + 页式虚拟存储器的优点是，**页面的长度固定，页表简单，调入方便**。缺点是，**由于程序不可能正好是页面的整数倍，最后一页的零头将无法利用造成浪费，并且页不是逻辑上独立的实体，所以处理、保护和共享都不及段式虚拟存储器方便**

  + `快表`（**TLB，Translation Lookaside Buffer，转换检测缓冲区**）

    + 由**地址转换**过程可知，访存时，先访问一次主存去查页表，再访问主存才能取得数据。如果**缺页**，那么还要进行页面替换、页面修改等，因此采用**虚拟存储机制**后，访问主存的次数更多了
    + 依据程序执行的**局部性原理**，在一段时间内总是经常访问某些页时，若把这些页对应的页表项存放在**高速缓冲器**组成的**快表（TLB）**中，则可以明显提高效率。相应地把**放在主存中的页表**称为**慢表（Page）**。在地址转换时，首先查找**快表**，若命中，则无须访问主存中的页表。
    + **快表**通常采用**全相联**或**组相联**方式，每个TLB项由**页表**表项内容加上一个TLB标记字段组成，TLB标记用来表示该**表项**取自页表中哪个虚页号对应的页表项，因此，TLB标记的内容在全相联方式下就是该页表项对应的**虚页号**；组相联方式下则是对应虚页号的**高位部分**，而虚页号的**低位**部分用于选择TLB组的**组索引**。
  
  + `具有TLB和Cache的多级存储系统`
  
    + 如下图是一个具有**TLB**和**Cache**的多级存储系统，其中**Cache**采用二路组相联方式。CPU给出一个32位的虚拟地址，TLB采用全相联方式，每一项都有一个比较器，查找时将虚页号与每个TLB标记字段同时进行比较
      + 若有某一项相等且对应有效位为1，则TLB命中，此时可直接通过TLB进行地址转换
      + 若未命中，则TLB缺失，需要访问主存去查页表
      
    + 图中所示的是**两级页表**方式，虚页号被分成**页目录索引**和**页表索引**两部分，由这两部分得到对应的**页表项**，从而进行地址转换，并将相应表项调入TLB，若TLB已满，则还需要采用替换策略。
    
    + 完成由虚拟地址到物理地址的转换后，Cache机构根据**映射方式**将物理地址划分成多个字段，然后根据映射规则找到对应的Cache行或组，将对应**Cache**行中的标记与**物理地址**中的**高位**部分进行比较，若相等且对应有效位为1，则Cache命中，此时根据块内地址取出对应的字送CPU。
    
      ![image-20220614111206307](../images/image-20220614111206307.png)
    
    + 查找时，**快表**和**慢表**也可以同步进行，若**快表**中有此虚页号，则能很快地找到对应的实页号，并使**慢表**的查找作废，从而就能做到虽采用**虚拟存储器**但访问主存速度几乎没有下降。
    
    + 在一个具有Cache和TLB的虚拟存储系统中，CPU一次访存操作可能涉及**TLB、页表、Cache、主存**和**磁盘**的访问，访问过程如下图。可以看出，CPU访存过程中存在**三**种缺失情况
    
      + `TLB缺失`：要访问的页面对应的**页表项**不在**TLB**中
      + `Cache缺失`：要访问的**主存块**不在**Cache**中
      + `缺页（Page）`：要访问的**页面**不在**主存**中
    
      ![image-20220614112321567](../images/image-20220614112321567.png)
    
    + **三**种缺失的几种可能组合如下
    
      + 最好的情况是第**1**种组合，此时无须访问主存
    
      + 第**2**和第**3**种组合都需要访问一次主存
    
      + 第**4**种组合需要访问两次主存
    
      + 第**5**种组合发生**缺页异常**，需要访问磁盘，并且至少访问两次主存
    
      + **Cache缺失**处理由**硬件**完成
    
      + **缺页**处理由**软件**完成
    
      + **操作系统**通过**缺页异常处理程序**来实现
    
      + **TLB缺失**既可以用**硬件**又可以用**软件**来处理，比如操作系统有专门的**TLB缺失异常处理**程序
    
        ![image-20220614112721798](../images/image-20220614112721798.png)

### 段式虚拟存储器

+ **段**是按**程序的逻辑结构**划分的，各个段的长度因程序而**异**。

+ 把虚拟地址分为**两部分**：**段号**和**段内地址**

+ **虚拟地址**到**实地址**之间的变换是由**段表**来实现的

+ **段表**是程序的**逻辑段**和在主存中**存放位置**的对照表

+ **段表**的每行记录与某个段对应的段号、装入位、段起点和段长等信息。

+ 由于**段**的长度可变，所以**段表**中要给出各段的**起始地址**和**段的长度**

+ CPU根据虚拟地址访存时，首先根据**段号**与**段表基地址**拼接成对应的**段表行**，然后根据该**段表行**的装入位判断该段是否已调入主存（**装入位为1，表示该段已调入主存；装入位为0，表示该段已不在主存中**）。已调入主存时，从段表读出该段在主存中的起始地址，与段内地址（**偏移量**）相加，得到对应的主存实地址。

+ 段式虚拟存储器的地址变换过程如下

  ![image-20220614113457891](../images/image-20220614113457891.png)

+ 段式虚拟存储器

  + 优点是**段的分界与程序的自然分界相对应，因而具有逻辑独立性，使得它易于编译、管理、修改和保护，也便于多道程序的共享**
  + 缺点是**因为段长度可变，分配空间不便，容易在段间留下碎片，不好利用，造成浪费**

### 段页式虚拟存储器

+ 把程序**按逻辑**结构分段，每段再划分为固定大小的**页**，主存空间页划分大小相等的**页**，程序对主存的调入、调出仍以**页**为基本传送单位，这样的虚拟存储器称为**段页式虚拟存储器**。
+ 在段页式虚拟存储器中，每个程序对应一个**段表**，每段对应一个**页表**，**段的长度**必须是**页长**的整数倍，**段的起点**必须是某一页的起点。
+ **虚地址**分为**段号、段内页号、页内地址**三部分。CPU根据虚地址访存时
  + 首先根据**段号**得到**段表地址**
  + 然后从**段表**中取出该段的**页表起始地址**，与**虚地址**段内页号合成，得到**页表**地址
  + 最后从**页表**中取出**实页号**，与**页内地址**拼接形成主存**实地址**
+ 段页式虚拟存储器的优点是，**兼具页式**和**段式**虚拟存储器的优点，**可以按段实现共享和保护**。缺点是**地址变换过程中需要两次查表，系统开销较大**。

### 虚拟存储器与Cache的比较

+ `相同之处`
  + 目标都是为了**提高系统性能**，两者都有**容量、速度、价格**的梯度
  + 都把数据划分为**小信息块**，并作为基本的传递单位，虚存系统的信息块更大
  + 都有**地址的映射、替换算法、更新策略**等问题
  + 依据程序的**局部性原理**应用“快速缓存的思想”，将活跃的数据放在**相对高速**的部件中
+ `不同之处`
  + **Cache**主要**解决系统速度**，而**虚拟存储器**却是为了**解决主存容量**
  + **Cache**全由硬件实现，是硬件存储器，对所有程序员透明；**虚拟存储器**由OS和硬件共同实现，是逻辑上的存储器，对系统程序员不透明，但对应用程序员透明
  + 对于**不命中**性能影响，因为CPU的速度约为Cache的**10**倍，主存的速度为硬盘的**100**倍以上，因此**虚拟存储器系统不命中**时对系统性能影响更大。
  + **CPU**与**Cache**和**主存**都建立了直接访问的通路，而**辅存**与**CPU**没有直接通路。也就是说在**Cache不命中**时**主存**能和**CPU**直接通信，同时将数据**调入Cache**；而**虚拟存储器系统不命中**时，只能先由**硬盘**调入**主存**，而不能直接**和CPU通信**。

## 总结

+ **相联存储器**：基本原理是把存储单元所存内容的某一部分作为检索项（即**关键字项**）去检索该存储器，并将存储器中与、该检索项符合的存储单元内容进行读出或写入。所以它是**按内容或地址**进行寻址的，价格较为昂贵，一般用来制作**TLB（Translation Lookaside Buffer，CPU的一种缓存，转译后备缓冲器/页表缓存/转址旁路缓存），相联Cache**等。

+ 易失性存储器和刷新的区别

  易失性存储器是指断电后数据丢失，SRAM和DRAM都满足断电内容消失，但需要刷新的只有DRAM，而SRAM不需要刷新。
  
+ $\rm \overline{CS}$是**片选信号**，$\rm \overline{WE}$是**读写控制信号**。

  + CPU要实现对存储单元的访问，首先要选择**存储芯片**，即进行**片选**；然后再从选中的芯片中依**地址码**选择出相应的存储单元，以进行数据的存取，这称为**字选**。片内的字段是由CPU送出的N条低位**地址线**完成的，地址线直接接到所有存储芯片的地址输入端，而存储芯片的**片选信号**则大多是通过**高位地址译码**后产生的。
  + 读写控制线可以由一根WE控制，**低电平写入，高电平读出**，也可以由OE和WE两线控制，**OE低电平读出，WE低电平写入**
  
+ 存储器的**层次结构**主要体现在何处？为何要分这些层次？计算机如何管理这些层次？

  + **层次结构**主要体现在**Cache-主存**和**主存-辅存**这两个存储层次上
  + **Cache-主存**层次在存储系统中，主要对CPU访存起**加速作用**，即从整体运行的效果分析，CPU访存速度加快，接近于**Cache的速度**，而寻址**空间和价位**却接近于**主存**
  + **主存-辅存**层次在存储系统中主要起**扩容**作用，即从程序员角度看，他所使用的存储器的**容量和价位**接近于**辅存**，而**速度**接近于**主存**
  + **主存与Cache**之间的信息调度功能全部由**硬件**自动完成。而**主存与辅存**层次的调度目前广泛采用**虚拟存储技术**实现，即将**主存**与**辅存**的一部分通过软/硬结合的技术组成**虚拟存储器**，程序员可用这个比主存实际空间（**物理地址空间**）大得多的虚拟地址空间（**逻辑地址空间**）编程，当程序运行时，再由软/硬件自动配合完成**虚拟地址空间**与**主存实际物理空间**的转换。因此，这**两个层次**上的**调度**或**转换**操作对于程序员来说都是**透明**的。

+ **存取周期**和**存取时间**有何区别

  + **存取时间**仅为完成一次操作的时间

  + **存取周期**不仅包含操作时间，而且包含操作后线路的恢复时间，即
    $$
    存取周期=存取时间+恢复时间
    $$

+ 在虚拟存储器中，**页面**是设置得大一些好还是小一些好

  + 页面**太小**时，平均页内剩余空间较少，可**节省存储空间**，但会使**页表增大**，不能充分利用访存的**空间局部性**来提高命中率
  + 页面**太大**时，可**减少页表空间**，但平均页内剩余空间较大，会浪费较多存储空间，页面太大还会使页面**调入/调出**的时间较长

+ **存取时间**就是**存储周期**吗？

  **不是**

  + 存取时间是**执行一次读操作**或**写操作**的时间，分为**读出时间**和**写入时间**
    + **读出时间**是从**主存接收到有效地址**开始到**数据稳定**为止的时间
    + **写入时间**是从**主存接收到有效地址**开始到**数据写入被写单元**为止的时间
  + 存储周期是指存储器进行**连续两次**独立地**读或写**操作所需的最小时间间隔。
  + 通常**存储周期**大于**存取时间**

+ **Cache行大小**和**命中率**之间有什么关系

  + 行的长度较**大**，可以充分利用程序访问的**空间局部性**，使一个较大的局部空间被一起调到Cache中，因而可以**增加命中机会**。缺点是
    + 行长较大，使**失效损失**变大。即若未命中，则需花更多时间从主存读块
    + 行长较大，Cache项数变少，因而**命中的可能性变小**

+ 发生**取指令Cache缺失**的处理过程是什么

  + **程序计数器**恢复当前指令的值
  + 对**主存**进行读的操作
  + 将读入的指令写入**Cache**中，更改**有效位**和**标记位**
  + 重新执行当前指令

+ 关于Cache的一些小知识

  + **多级Cache**
    + 现代计算机系统一般采用**多级Cache系统**。CPU执行指令时，先到**速度最快的一级Cache（L1 Cache）**中寻找指令或数据，找不到时，再到**速度次快的二级Cache（L2 Cache）**中找，最后到**主存**中找

  + **指令Cache和数据Cache**
    + **指令**和**数据**可以分别存储在不同的Cache中（**L1 Cache**一般会这么做），这种结构也称**哈佛Cache**，其特点是**允许CPU在同一个Cache存储周期内同时提取指令和数据**，由于指令执行过程**取指**和**取数据**都有可能访问**Cache**，因此这一特性可以**保证不同的指令同时访存**


# 指令系统

## 指令格式

**指令**是**指示计算机执行某种操作的命令**。一台计算机所有指令的集合构成该机的指令系统，也称**指令集**。指令系统是计算机的主要属性，位于**硬件**和**软件**的交界面上

+ 指令的基本格式

  + **操作码**+**地址码**

    ![image-20220614170834903](../images/image-20220614170834903.png)

  + **操作码**指出指令中该指令**应该执行什么性质的操作**以及**具有何种功能**

  + **操作码**是**识别指令**、**了解指令功能**及**区分操作数地址内容**的组成和使用方法等的关键信息

    + 例如：指出是**算术加运算**还是**算术减运算**，是**程序转移**还是**返回操作**

  + **地址码**给出**被操作的信息（指令或数据）的地址**，包括参加运算的一个或多个**操作数所在的地址**、运算**结果的保存地址**、**程序的转移地址**、被调用的**子程序的入口地址**等。

  + **指令的长度**是指一条指令中所包含的**二进制代码的位数**。**指令字长**取决于**操作码**的长度、**操作数地址码**的长度和**操作数地址**的个数。**指令长度**与**机器字长**没有固定的关系，它可以等于机器字长，也可以大于或小于机器字长。

  + 把**指令长度**等于机器字长的指令称为**单字长指令**，**指令长度**等于**半个**机器字长的指令称为**半字长指令**，**指令长度**等于**两个**机器字长的指令称为**双字长指令**。

  + 一个指令系统中，若**所有**指令的**长度都是相等**的，则称为**定长指令字结构**。定字长指令的**执行速度快，控制简单**。若各种指令的长度随指令功能而异，则称为**变长指令字结构**。然而，因为**主存**一般是按**字节**编址的，所以指令字长多为**字节的整数倍**

  + 根据指令中**操作数地址码的数目**的不同，可将指令分成以下几种格式

    + `零地址指令`

      + 只给出**操作码OP**，没有**显式地址**。这种指令有**两**种可能

        + 不需要操作数的指令，如**空操作指令**、**停机指令**、**关中断指令**等

        + 零地址的运算类指令仅用在**堆栈计算机**中。通常参与运算的两个操作数隐含地从**栈顶**和**次栈顶**弹出，送到运算器进行运算，运算结果再隐含地**压入堆栈**

          ![image-20220614191432280](../images/image-20220614191432280.png)

    + `一地址指令`

      + 有**两**种可能

        + 只有**目的操作数**的**单**操作数指令，按$A_1$地址读取操作数，进行OP操作后，结果存回原地址。

          + 指令含义：**$OP(A_1) \rightarrow A_1$**
            + 如操作码的含义是**加1、减1、求反、求补**等

        + 隐含约定目的地址的**双**操作数指令，按指令地址$A_1$可读取源操作数，指令可隐含约定另一个操作数由ACC（累加器）提供，运算结果也将存放在ACC中。

          + 指令含义：**$(ACC)OP(A_1) \rightarrow ACC$**

            + 若指令字长为32位，操作码占8位，1个地址码字段占24位，则指令操作数的直接寻址范围为$2^{24}=16M$

            ![image-20220614192153326](../images/image-20220614192153326.png)

    + `二地址指令 `

      + 对于常用的算术和逻辑运算指令，往往要求使用两个操作数，需分别给出**目的操作数**和**源操作数**的地址，其中**目的操作数**还用于保存本次的运算结果。

        + 指令含义：**$(A_1)OP(A_2) \rightarrow A_1$**

          + 若指令字长为32位，操作码占8位，两个地址码字段各占12位，则指令操作数的直接寻址范围为$2^{12}=4K$
    
          ![image-20220614194148422](../images/image-20220614194148422.png)
    
    + `三地址指令`
    
      + 若指令字长为32位，操作码占8位，3个地址码字段各占8位，则指令操作数的直接寻址范围为$2^8=256$。若地址字段均为主存地址，则完成一条三地址需要4次访问存储器（取指令1次，取两个操作数2次，存放结果1次）
    
        + 指令含义：**$(A_1)OP(A_2) \rightarrow A_3$**
    
        ![image-20220614195047156](../images/image-20220614195047156.png)
    
    + ` 四地址指令` 
    
      + 若指令字长为32位，操作码占8位，4个地址码字段各占6位，则指令操作数的直接寻址范围为$2^6=64$
    
        + 指令含义：**$(A_1)OP(A_2) \rightarrow A_3, A_4=下一条将要执行指令的地址$**
    
          ![image-20220614195302669](../images/image-20220614195302669.png)

### 定长操作码指令格式

定长操作码指令在指令字的**最高位**部分分配固定的**若干位（定长）**表示操作码。一般n位操作码字段的指令系统最大能够表示$2^n$条指令。定长操作码对于简化计算机硬件设计，提高指令译码和识别速度很有利。当**计算机字长为32位或更长时，这是常规用法**

### 扩展操作码指令格式

+ 为了在指令字长有限的前提下仍**保持比较丰富的指令种类**，可采取**可变长度操作码**，即全部指令的**操作码**字段的**位数**不固定，且分散地放在**指令字**的**不同位置上**，显然，这将增加**指令译码**和**分析**的难度，使控制器的设计复杂化。

+ 最常见的变长操作码方法是**扩展操作码**，它使**操作码**的长度随**地址码**的**减少**而**增加**，不同**地址数**的**指令**可具有不同长度的操作码，从而在满足需要的前提下，有效地缩短指令字长。下图为一种扩展操作码的安排方式（1111、11111111、111111111111留作**扩展操作码**之用）

  ![image-20220614201920467](../images/image-20220614201920467.png)

+ 除了以上这种安排之外，还有许多其他扩展方法，如**形成15条三地址指令、12条二地址指令、63条一地址指令、16条零地址指令**共**106**条指令 

+ 在设计扩展操作码指令格式时，必须注意以下**两**点

  + 不允许**短码**是**长码**的**前缀**，即**短操作码**不能与**长操作码**的前面部分的代码相同
  + 各指令的**操作码**一定不能重复

+ 通常情况下，对使用**频率较高**的指令分配**较短**的操作码，对使用**频率较低**的指令分配**较长**的操作码，从而尽可能减少**指令译码和分析**的时间

### 指令的操作类型

+ `数据传送`

  传送指令通常有**寄存器**之间的传送（**MOV**），从**内存单元**读取数据到**CPU寄存器**（**LOAD**），从**CPU寄存器**写数据到**内存单元**（**STORE**）等。

+ `算术和逻辑运算`

  这类指令主要有**加（ADD）、减（SUB）、比较（CMP）、乘（MUL）、除（DIV）、加1（INC）、减1（DEC）、与（AND）、或（OR）、取反（NOT）、异或（XOR）**等

+ `移位操作`

  主要有**算法移位、逻辑移位、循环移位**等

+ `转移操作`

  + 主要有**无条件转移（JMP）、条件转移（BRANCH）、调用（CALL）、返回（RET）、陷阱（TRAP）**等。**无条件转移指令**在任何情况下都执行**转移操作**，而**条件转移指令**仅在特定条件满足时才执行**转移操作**，转移条件一般是某个**标志位**的值，或者是**两个或两个以上**的标志位组合
  + **调用指令**和**转移指令**的区别
    + 执行**调用指令**时必须保存下一条指令的地址（**返回地址**），当子程序执行结束时，根据返回地址**返回**到主程序**继续执行**
    + **转移指令**不返回执行

+ `输入输出操作`

  这类指令用于完成**CPU**与**外部设备**交换**数据**或**传送控制命令**及**状态**信息。

## 指令的寻址方式

+ 寻址方式是指寻找**指令**或**操作数**有效地址的方式，即确定本条指令的**数据地址**及下一条待执行指令的地址的方法。寻址方式分为**指令寻址**和**数据寻址**两大类。
+ 指令中的**地址码**字段并不代表**操作数**的**真实地址**，这种地址称为**形式地址（A）**。**形式地址**结合**寻址方式**，可以计算出操作数在存储器中的**真实地址**，这种地址称为**有效地址（EA）**
  + （A）表示地址为A的数值，A既可以是**寄存器编号**，也可以是**内存地址**。对应的（A）就是**寄存器**中的数值，或相应**内存单元**的数值。例如，EA=（A）意思是**有效地址是地址A中的数值**

### 指令寻址和数据寻址

+ `指令寻址`（**寻找下一条将要执行的指令地址**）

  + `顺序寻址方式`

    + 通过**程序计数器（PC）**加1（**1个指令字长**），自动形成下一条指令的地址

  + `跳跃寻址方式`

    + 通过**转移类**指令实现。所谓跳跃，是指下条指令的地址码不由**程序计数器**给出，而由**本条指令**给出下条指令地址的**计算方式**。

      > 是否跳跃可能受到**状态寄存器**和**操作数**的控制，而跳跃到的地址分为**绝对地址（由标记符直接得到）**和**相对地址（相对于当前指令地址的偏移量）**，跳跃的结果是当前指令修改**PC值**，所以下一条指令仍然通过**程序计数器（PC）**给出

+ `数据寻址`（**寻找操作数的地址**）

  + 方式较多，为区别各种方式，通常在**指令字**中设一个字段，用来指明属于哪种**寻址方式**，由此可得指令的格式如下所示

    ![image-20220615082327051](../images/image-20220615082327051.png)

### 常见的数据寻址方式

+ `隐含寻址`

  + **不明显给出操作数的地址，而在指令中隐含操作数的地址**

    + 单地址的指令格式就不明显地在地址字段中指出第二操作数的地址，而规定累加器（ACC）作为第二操作数地址，指令格式明显指出的仅是第一操作数的地址。因此，**累加器（ACC）**对**单地址指令格式**来说是隐含寻址

  + 优点是有利于**缩短指令字长**，缺点是**需增加存储操作数**或**隐含地址的硬件**

    ![image-20220615082936980](../images/image-20220615082936980.png)

+ `立即（数）寻址` 

  + 地址字段指出的不是操作数的**地址**，而是操作数**本身**，又称**立即数**。下图中，**#**表示立即寻址特征，**A**就是操作数本身

  + 数据采用**补码**形式存放

  + 优点是**指令在执行阶段不访问主存，指令执行时间最短**，缺点是**A的位数限制了立即数的范围**

    ![image-20220615083339018](../images/image-20220615083339018.png)

+ `直接寻址`

  + 指令字中的**形式地址A**是**操作数**的**真实地址**EA，即EA=A，如下图

  + 优点是**简单，指令在执行阶段仅访问一次主存，不需要专门计算操作数的地址**。缺点是**A的位数决定了该指令操作数的寻址范围，操作数的地址不易修改**

    ![image-20220615083714522](../images/image-20220615083714522.png)

+ `间接寻址`

  + 相对于**直接寻址**而言的，指令的**地址字段**给出的**形式地址**不是**操作数**的**真正地址**，而是操作数有效地址所在的**存储单元的地址**，也就是**操作数地址的地址**，即**EA=（A）**，如下图

  + **间接寻址**可以是**一次间接寻址**，还可以是**多次间接寻址**。

    ![image-20220615084047148](../images/image-20220615084047148.png)

  + 如上图，主存字第一位为**1**时，表示取出的仍不是操作数的地址，即**多次间址**；主存字第一位为**0**时，表示取得的是**操作数的地址**。

  + 间接寻址的**优点**是**可扩大寻址范围**（有效地址EA的位数大于形式地址A的位数），**便于编制程序**（用间接寻址可方便的完成子程序返回）。

  + 间接寻址的**缺点**是**指令在执行阶段要多次访存**（一次间接寻址需两次访存，多次间接寻址需根据存储字的最高位确定访存次数）。由于**访问速度过慢**，这种寻址方式并不常用。

    > 一般问到扩大寻址范围时，通常是**寄存器间接寻址**

+ `寄存器寻址`

  + 在指令字中直接出给操作数所在的**寄存器编号**，即EA=$\rm R_i$，其操作数在由$\rm R_i$所知的寄存器内，如下图所示
  + 优点是**指令在执行阶段不访问主存，只访问寄存器**，因寄存器数量较少，对应地址码长度较小，使得指令字短且因不用访存，所以**执行速度快**，支持**向量/矩阵运算**
  + 缺点是**寄存器价格昂贵，计算机中的寄存器个数有限**

+ `寄存器间接寻址`

  + 在寄存器$R_i$中给出的不是一个**操作数**，而是操作数所在**主存单元的地址**，即EA=（$R_i$），如下图

    ![image-20220615093627265](../images/image-20220615093627265.png)

+ `相对寻址`

  + 把**程序计数器（PC）**的内容加上指令格式中的**形式地址A**而形成操作数的**有效地址**，即EA=（PC）+A，其中**A**是相对于当前指令地址的**位移量**，可正可负，**补码**表示，如下图

  + **A**的**位数**决定**操作数**的**寻址范围**。

  + 优点是**操作数的地址**不是**固定**的，随PC值的变化而变化，且与指令地址之间总是**相差一个固定值**，因此便于程序浮动。相对寻址广泛应用于**转移指令**。

    > 对于转移指令**JMP A**，当CPU从存储器中取出一字节时，会自动执行$(PC)+1 \rightarrow PC$。若转移指令的地址为X，且占2B，在取出该指令后，PC的值会增2，即$(PC)=X+2$，这样在执行完该指令后，会自动跳转到X+2+A的地址继续执行。

+ `基址寻址`

  + 将CPU中**基址寄存器**（BR）的内容加上**指令格式中的形式地址A**而形成操作数的有效地址，即EA=（BR）+A。其中基址寄存器既可采用专用寄存器，又可采用通用寄存器。如下图

    ![image-20220615160028912](../images/image-20220615160028912.png)

  + 基址寄存器是面向**操作系统**的，其内容由**操作系统**或**管理程序**确定，主要用于解决**程序逻辑空间**与**存储器物理空间**的**无关性**。在程序执行过程中，基址寄存器的**内容**不变（作为**基址**），**形式地址**可变（作为**偏移量**）。采用**通用寄存器**作为基址寄存器时，可由用户决定哪个寄存器作为基址寄存器，但其内容仍由**操作系统**确定。

  + 基址寻址的优点是**可扩大寻址范围**（**基址寄存器**的位数大于**形式地址A**的位数）；用户不必考虑自己的程序存于**主存**的哪个空间区域，因此有利于**多道程序设计**，并可用于编制**浮动程序**，但**偏移量**（形式地址A）的**位数较短**。

+ `变址寻址`

  + **有效地址EA**等于指令字中的**形式地址**A与**变址寄存器**IX的内容之和，即EA=（IX）+A，其中IX为**变址寄存器**（专用），也可用**通用寄存器**作为变址寄存器。如下图

    ![image-20220616082242860](../images/image-20220616082242860.png)

  + **变址寄存器**是面向用户的。在程序执行过程中，变址寄存器的内容可由用户改变（作为偏移量），形式地址A不变（作为基地址）。

  + 变址寻址的**优点**是**可扩大寻址范围**（变址寄存器的位数大于形式地址A的位数）；在数组处理过程中，可设定A为数组的首地址，不断改变变址寄存器IX的内容，便可很容易形成数组中任一数据的地址，特别适合**编制循环程序**。偏移量（变址寄存器IX）的**位数**足以表示整个**存储空间**。

  + **变址寻址**与**基址寻址**的有效地址形成过程极为相似。但从本质上讲，两者有较大的区别。

    + `基址寻址`
      + 面向**系统**，主要用于为**多道程序**或**数据**分配存储空间，因此基址寄存器的内容通常由**操作系统**或**管理程序**确定，在程序的执行过程中其值**不可变**，而指令字中的A是**可变**的
    + `变址寻址`
      + 立足于**用户**，主要用于处理**数组**问题，在变址寻址中，变址寄存器的内容由用户设定，在程序执行过程中其值**可变**，而指令字中的A是**不可变**的。

+ `堆栈寻址`

  + 存储器（或**专用寄存器组**）中一块特定的、按**后进先出（LIFO）**原则管理的存储区，该存储区中读/写单元的地址是用一个特定的寄存器给出的，该寄存器称为**堆栈指针（SP）**。堆栈可分为**硬堆栈**和**软堆栈**两种
    + `硬堆栈`（**寄存器堆栈**）
      + **成本较高**，不适合做大容量的堆栈
    + `软堆栈`
      + 从**主存**中划出一段区域来做堆栈是最合算、最常用的方法
  + 采用**堆栈结构**的计算机系统中，大部分指令表面上都表现为**无操作数指令**的形式，因为操作数地址都隐含使用了**SP**。通常情况下，在读/写堆栈中的一个单元的前后都伴有自动完成对SP内容的增量或减量操作

+ 下图总结了**寻址方式、有效地址、访存次数（不包含为了取本条指令而做的访存）**

  |      寻址方式      |   有效地址   | 访存次数 |
  | :----------------: | :----------: | :------: |
  |      隐含寻址      |   程序指定   |  **0**   |
  |      立即寻址      | A即是操作数  |    0     |
  |      直接寻址      |     EA=A     |    1     |
  |    一次间接寻址    |   EA=（A）   |    2     |
  |     寄存器寻址     |   EA=$R_i$   |    0     |
  | 寄存器间接一次寻址 | EA=（$R_i$） |    1     |
  |      相对寻址      | EA=（PC）+A  |    1     |
  |      基址寻址      | EA=（BR）+A  |    1     |
  |      变址寻址      | EA=（IX）+A  |    1     |

### X86汇编指令入门

+ 相关寄存器

  + X86处理器中有**8**个**32**位的通用寄存器。如下图

    ![image-20220616190846258](../images/image-20220616190846258.png)

  + 为了向后兼容，**EAX、EBX、ECX、EDX**的**高两位**字节和**低两位**字节可以独立使用，**E**为**Extended**，表示**32**位的寄存器。

    + EAX的低两位字节称为**AX**，而AX的高低字节又可分别作为两个**8**位寄存器，分别称为**AH**和**AL**。

  + 寄存器的名称与**大小写**无关，即可用**EAX**，又可用**eax**。

  + 除**EBP**和**ESP**外，其他几个寄存器的用途是比较**任意**的

+ 寻址模式和内存分配

  + 寻址模式	
    + X86提供了一种灵活的内存寻址方式
      + 举例mov指令，mov用于在**内存**和**寄存器**之间移动数据，它有两个参数：**目的地址**和**源地址**
  + 数据类型长度规定
    + **汇编语言**中声明**内存大小**时，一般显式地使用**DB**（字母D表示Data，字母B表示Byte）、**DW**（字母W表示Word，**2Bytes**）和**DD**（第二个D表示Double Word， **4Bytes**），这样就能很好的指导编译器分配内存空间
    + 若无特殊标识，X86提供了三个**指示规则标记**，分别为**BYTE PTR、WORD PTR、DWORD PTR**

+ 常用指令

  + 汇编指令通常可以分为**数据传送指令、逻辑计算指令、控制流指令**。以下是用于**操作数**的标记，分别表示**寄存器**、**内存**、和**常数**

    + `<reg>`
      + 任意寄存器，若其后带有数字，则指定其**位数**
        + **\<reg32>**表示32位寄存器（**EAX, EBX, ECX, EDX, ESI, EDI, ESP, EBP**）
        + **\<reg16>**表示16位寄存器（**AX, BX, CX, DX**）
        + **\<reg8>**表示8位寄存器（**AH, AL, BH, BL, CH, CL, DH, DL**）
    + `<mem>`
      + 表示内存地址
        + 如**[eax], [var+4], dword ptr [eax+ebx]**
    + `<con>`
      + 表示8位、16位、32位常数，对同一指令的不同用途有多种**编码方式**，比如mov指令就有28种机内编码，用于不同**操作数类型**或用于**特定寄存器**，

  + `数据传送指令`

    + `mov`

      + 将**第二个**操作数（寄存器的内容、内存中的内容或常数值）复制到**第一个**操作数（寄存器或内存）。但不能用于直接从**内存**复制到**内存**

        ```assembly
        mov eax, ebx    ; 将ebx值复制到eax
        mov byte ptr [var], 5 ; 将5保存到var值指示的内存地址的一字节中
        ```

    + `push`

      + 将**操作数**压入内存的栈，常用于**函数调用**。**ESP**是栈顶，压栈前先将ESP值减4（**栈**增长方向与**内存地址**增长方向相反），然后将**操作数**压入ESP指示的地址

        ```assembly
        push <reg32>
        push <mem>
        push <con32>
        ```

        > 栈中元素固定为**32**位

  + `算术和逻辑运算指令`

    + `add/sub`

      + add指令将两个操作数相加，相加的结果保存到**第一个**操作数。

      + sub指令用于两个操作数相减，相减的结果保存到**第一个**操作数中

        ```assembly
        add <reg>,<reg> 
        sub <reg>,<reg>
        ```

    + `inc/dec`

      + 分别表示将**操作数**自加1，自减1

        ```assembly
        inc <reg>
        dec <reg>
        ```

    + `imul`

      + **带符号整数**乘法指令，有两种格式
        + **两个**操作数，将两个操作数相乘，并将结果保存在**第一个**操作数中，**第一个**操作数必须为**寄存器**
        + **三个**操作数，将**第二个**和**第三个**操作数相乘，并将结果保存在**第一个**操作数中，第一个操作数必须为**寄存器**。
      + 乘法操作结果可能**溢出**，则编译器置**溢出标志OF=1**，以使CPU调用**溢出异常处理程序**

    + `idiv`

      + idiv是带符号整数除法指令，**只有一个**操作数，即**除数**，而**被除数**则为**edx:eax**中的内容（64位整数），操作结果有两部分：**商**和**余数**，商送到eax，余数送到edx

        ```assembly
        idiv <reg32>
        idiv <mem>
        ```

    + `and/or/xor` 

      + and、or、xor指令分别是**逻辑与**、**逻辑或**、**逻辑异或**。用于**操作数**的位操作，操作结果放在**第一个**操作数中

        ```assembly
        and <reg>, <reg>
        or <reg>,<reg>
        xor <reg>,<reg>
        ```

    + `not`

      + 翻转指令，将操作数中每一位翻转

    + `neg`

      + neg是**取负**指令

    + `shl/shr`

      + 逻辑移位指令，shl为**逻辑左移**，shr为**逻辑右移**，第一个操作数表示**被操作数**，第二个操作数指示**移位的位数**

        ```assembly
        shl <reg>, <con8>
        shr <reg>,<cl>
        ```

  + `控制流指令`

    + X86处理器维持着一个指示**当前执行指令**的指令指针（IP），当一条指令执行后，此指针自动指向下一条指令。
    + **IP寄存器**不能直接操作，但可以用控制流指令更新
    + 通常用标签（label）指示**程序中的指令地址**，在X86汇编代码中，可在任何指令前加入标签
    + `jmp`
      + jmp指令**控制IP转移到label所指示的地址**（从label中取出指令执行）
    + `jcondition`
      + 条件转移指令，依据处理机状态字中的一系列条件状态转移。处理机状态字中包括指示最后一个算术运算结果是否为0，运算结果是否为负数等
    + `cmp`
      + cmp指令用于**比较两个操作数**的值，并根据比较结果设置处理机状态字中的条件码
    + `call/ret`
      + 这两条指令分别实现子程序（过程、函数等）的**调用**及**返回**。
      + call指令先将**当前执行指令**地址入栈，然后无条件转移到由标签指示的指令。与其他简单的跳转指令不同，call指令**保存之前调用的地址信息（当call指令结束后，返回调用之前的地址）**
      + ret指令实现**子程序的返回机制**，ret指令弹出栈中保存的指令地址，然后无条件转移到保存的指令地址执行。

## CISC和RISC的基本概念

+ `CISC`（**Complex Instruction Set Computer**）
  + **增强原有指令**的功能，设置更为复杂的新指令实现软件功能的硬化
    + 典型的有采用X86架构的计算机
+ `RISC`（**Reduced Instruction Set Computer**）
  + **减少指令种类**和**简化指令**功能，提高指令的执行速度
    + 典型的有ARM、MIPS架构的计算机

### 复杂指令系统计算机（CISC）

+ 特点
  + 指令系统复杂庞大，指令数目一般为**200条以上**
  + 指令的**长度不固定**，指令**格式多**，**寻址方式多**
  + 可以访存的指令**不受限制**
  + 各种指令使用**频率相差很大**
  + 各种指令执行时间相差很大，大多数指令需**多个时钟周期**才能完成
  + 控制器大多数采用微程序控制。有些指令非常复杂，以至于**无法采用硬连线**控制
  + **难**以用优化编译**生成**高效的目标代码程序

### 精简指令系统计算机（RISC）

+ 特点
  + 选取使用频率最高的一些简单指令，复杂指令的功能由简单指令的**组合**来实现
  + **指令长度固定**，指令格式种类少，寻址方式**种类少**
  + 只有**Load/Store（取数/存数）**指令访存，其余指令的操作都在寄存器之间进行
  + CPU中**通用寄存器**的数量相当多
  + RISC一定采用**指令流水线**技术，大部分指令在一个时钟周期内完成
  + 以**硬布线**控制为主，不用或少用**微程序**控制
  + 特别重视**编译优化**工作，以减少程序执行时间

### CISC和RISC的比较

+ **RISC**相对于**CISC**的优点

  + **RISC**更能充分利用VLSI芯片的面积。CISC的控制器大多采用**微程序**控制，其控制存储器在CPU芯片内所占的面积达50%以上，而RISC控制器采用**组合逻辑控制**，其**硬布线**逻辑只占CPU芯片面积的10%左右
  + **RISC**更能提高**运算速度**，RISC的**指令数**、**寻址方式**和**指令格式**种类少，又设有多个通用寄存器，采用流水线技术，所以运算速度更快，大多数指令在**一个时钟周期**内完成
  + **RISC**便于设计，可降低成本，提高可靠性。RISC指令系统简单，因此**机器设计周期短**；其逻辑简单，因此可靠性高
  + **RISC**有利于编译程序代码优化。RISC**指令类型少**，**寻址方式少**，使编译程序容易选择更有效的**指令**和**寻址方式**，并适当地调整**指令顺序**，使得代码执行更**高效化**

+ CISC和RISC的对比

  | 对比项目           |                   CISC                   |                   RISC                   |
  | :----------------- | :--------------------------------------: | :--------------------------------------: |
  | `指令系统`         |                复杂、庞大                |                简单、精简                |
  | `指令数目`         |            一般大于**200**条             |            一般小于**100**条             |
  | `指令字长`         |                **不固定**                |                 **定长**                 |
  | `可访存指令`       |               **不加限制**               |          只有**Load/Store**指令          |
  | `各种指令执行时间` |               **相差较大**               |       绝大多数在**一个周期**内完成       |
  | `各种指令使用频度` |               **相差很大**               |              都比较**常用**              |
  | `通用寄存器数量`   |                 **较少**                 |                  **多**                  |
  | `目标代码`         | **难以**用优化编译生成高效的目标代码程序 | **采用**优化的编译程序，生成代码较为高效 |
  | `控制方式`         |         绝大多数为**微程序**控制         |        绝大多数为**组合逻辑控制**        |
  | `指令流水线`       |         **可以**通过一定方式实现         |               **必须**实现               |

## 总结

+ 指令分为哪几部分
  + 一条指令通常包括**操作码**字段和**地址码**字段
    + **操作码**指出指令中该指令应该执行什么性质的**操作**和具有何种**功能**，是**识别指令**、**了解指令功能**、**区分操作数地址内容**的**组成**和**使用方法**的关键信息。
    + **地址码**用于给出**被操作的信息**（指令或数据）的**地址**，包括参加运算的一个或多个**操作数**所在的地址、**运算结果**的保存地址、**程序**的转移地址、**被调用子程序**的入口地址
+ 寻址方式多和少有什么影响
  + 寻址方式**多样化**能让用户**编程**更为方便，但多重寻址方式会造成**CPU结构的复杂化**，也**不利于指令流水线的运行**
  + 寻址方式太少虽然能**提高CPU的效率**，但对于用户而言，少数几种寻址方式会使**编程**变得复杂，很难满足用户需求。
+ 常见**指令寻址方式**的**特点**和**适用情况**
  + **立即寻址**操作数获取便捷，通常用于**给寄存器赋初值**
  + **直接寻址**相对于**立即寻址**，**缩短了指令长度**
  + **间接寻址**扩大了**寻址范围**，便于**编制程序**，易于完成**子程序返回**
  + **寄存器寻址**的指令字较短，**指令执行速度较快**
  + **寄存器间接寻址**扩大了**寻址范围**
  + **基址寻址**扩大了**操作数**寻址范围，适用于**多道程序设计**，常用于为**程序**或**数据**分配存储空间
  + **变址寻址**主要用于处理**数组问题**，适合**编制循环程序**
  + **相对寻址**用户**控制程序的执行顺序、转移**等
  + **基址寻址**和**变址寻址**的区别。
    + 两种方式**有效地址**的形式都是**寄存器内容+偏移地址**
    + **基址寻址**中，程序员操作的是**偏移地址**，基址寄存器的内容由**操作系统**控制，在执行过程中是**动态**的
    + **变址寻址**中，程序员操作的是**变址寄存器**，**偏移地址是固定不变的**
+ 一个操作数在内存中可能占多个单元，怎样在指令中给出操作数的地址？
  + 现代计算机都采用**字节编址**方式，即一个内存单元只能存放**一字节**的信息。一个操作数（如char、int、float、double）可能是8位，16位，32位，64位等，因此可能占用1个、2个、3个、4个内存单元。也就是说，**一个操作数可能有多个内存地址对应**
  + 有**两种**不同的地址指定方式：**大端方式**和**小端方式**
    + `大端方式`
      + 指令中给出的地址是**操作数最高有效字节（MSB）所在的地址**
    + `小端方式`
      + 指令中给出的地址是**操作数最低有效字节（LSB）所在的地址**
+ 装入\存储（Load/Store）型指令有什么特点？
  + **装入\存储**型指令是用在规整型指令系统中的一种**通用寄存器型**指令风格。这种指令风格在RISC指令系统中较为常见。
  + 为了**规整指令格式**，使指令具有相同的长度，规定只有Load/Store指令才能访问内存。而**运算指令**不能直接访问内存，只能从寄存器取数进行运算，运算的结果也只能送到寄存器。因为**寄存器编号较短**，而主存地址位数较长，通过某种方式可使**运算指令**和**访存指令**的长度一致。
  + 这种风格的指令系统最大特点是：**指令格式规整，指令长度一致，一般为32位**。由于只有Load/Store指令才能访问内存，程序中可能会包含许多**装入指令**和**存储指令**，与一般通用寄存器型指令风格相比，其程序长度会更长。

# 中央处理器

## CPU的功能和基本结构

###  CPU的功能

+ 由**运算器**和**控制器**组成。
  + **控制器**，负责**协调并控制**计算机各部件执行程序的**指令序列**，包括**取指令、分析指令、执行指令**
  + **运算器**，**对数据进行加工**
+ CPU的具体功能
  + `指令控制`
    + 完成**取指令、分析指令、执行指令**的操作，即程序的**顺序控制**
  + `操作控制`
    + 一条指令的功能往往有若干操作信号的组合来实现。CPU管理并产生由内存取出的每条指令的操作信号，把各种操作信号送往相应的部件，从而**控制这些部件按指令的要求进行动作**
  + `时间控制`
    + 对各种操作加以**时间**上的控制，时间控制要为**每条指令按时间顺序提供应有的控制信号**
  + `数据加工`
    + 对数据进行**算术**和**逻辑**运算
  + `中断处理`
    + 对计算机运行过程中出现的**异常情况**和**特殊请求**进行处理

### CPU的基本结构

+ `运算器`
  + 接收从**控制器**送来的命令并执行相应的动作，对数据进行**加工和处理**。
  + 是计算机对数据进行加工处理的中心，主要由**算术逻辑单元（ALU）、暂存寄存器、累加寄存器（ACC）、通用寄存器组、程序状态字寄存器（PSW）、移位器、计数器（CT）**等组成
    + `算术逻辑单元`：进行**算术/逻辑运算**
    + `暂存寄存器`
      + 用于暂存从**主存**读来的数据，该数据不能存放在**通用寄存器**中，否则会破坏其原有内容。
      + 对**应用程序员**是透明的
    + `累加寄存器`
      + 是一个**通用寄存器**，用于存放**ALU运算的结果信息**，可以作为加法运算的一个输入端
    + `通用寄存器组`
      + 如**AX，BX，CX，DX，SP**等，用于**存放操作数**（源操作数、目的操作数、中间结果）和各种**地址信息**等。SP是堆栈指针，用于指示**栈顶的地址**
    + `程序状态字寄存器`
      + 保留由**算术逻辑运算指令**或**测试指令**的结果而建立的各种状态信息，如**溢出标志**（OF）、**符号标志**（SF）、**零标志**（ZF）、**进位标志**（CF）等。PSW中的这些位参与并决定**微操作**的形成
    + `移位器`
      + 对**操作数**或**运算结果**进行移位运算
    + `计数器`
      + 控制**乘除运算**的操作步数
  
+ `控制器`

  + 整个系统的**指挥中枢**，基本功能是**执行指令**，每条指令的执行是由控制器发出的一组**微操作**实现的
  
  + 有**硬布线控制器**和**微程序控制器**两种类型

  + 由**程序计数器**（PC）、**指令寄存器**（IR）、**指令译码器**、**存储器地址寄存器**（MAR）、**存储器数据寄存器**（MDR）、**时序系统**和**微操作信号发生器**等组成
  
    + `程序计数器`
      + 指出**下一条指令**在主存中的存放位置。CPU根据PC的内容去主存中取指令。因程序中指令（通常）是**顺序执行**的，所以PC有自增功能
  
    + `指令寄存器`
      + 保存**当前正在执行**的那条指令
  
    + `指令译码器`
      + 仅对**操作码**字段进行译码，向**控制器**提供特定的操作信号
  
    + `存储器地址寄存器`
      + 存放**要访问的主存单元的地址**
  
    + `存储器数据寄存器`
      + 存放向**主存**写入的信息或从主存读出的信息
  
    + `时序系统`
      + 产生各种时序信号，由统一时钟（CLOCK）**分频**得到
  
    + `微操作信号发生器`
      + 根据**IR**的内容（指令），**PSW**的内容（状态信息）及**时序信号**，产生控制整个计算机系统所需的各种**控制信号**，其结构有**组合逻辑型**和**存储逻辑型**两种
  
  + 工作原理
  
    + 根据**指令操作码**、**指令的执行步骤**（微命令序列）和**条件信号**来形成当前计算机各部件要用到的**控制信号**。计算机整机各硬件系统在这些**控制信号**的控制下协同运行，产生预期的执行结果。
  
    > CPU内部寄存器大致可分为**两**类，**用户可见的寄存器**，可对其编程，如**通用寄存器组**、**程序状态字寄存器**。另一类是**用户不可见的寄存器**，对用户透明，不可对其编程，如**存储器地址寄存器**、**存储器数据寄存器**、**指令寄存器**
  

## 指令执行过程

### 指令周期

+ CPU从**主存**中取出并**执行**一条指令的时间，不同指令的指令周期可能不同

+ 常用若干**机器周期**来表示，一个**机器周期**又包含若干**时钟周期**（也称**节拍**或**T周期**，是CPU操作的最基本单位）

+ 每个指令周期内的**机器周期数**可以不等，每个机器周期内的**节拍数**也可以不等

  ![image-20220621143856012](../images/image-20220621143856012.png)

+ **无条件转移指令JMP X**，在执行时不需要访问主存，只包含取指阶段（包括**取指**和**分析**）和**执行**阶段，所以其指令周期仅包含**取指**周期和**执行**周期

+ **间接寻址**指令，为了取操作数，需要先访问一次**主存**，取出**有效地址**，然后访问**主存**，取出**操作数**，因此包括了**间址周期**，**间址周期**介于**取指周期**和**执行周期**之间

+ 当CPU采用**中断**方式实现主机和I/O设备的信息交换时，CPU在每条指令执行结束前，都要发中断查询信号，若有中断请求，则CPU进入中断响应阶段，又称**中断周期**

+ 一个完整的指令周期应包括**取指**、**间址**、**执行**和**中断**共4个周期

  ![image-20220621145343667](../images/image-20220621145343667.png)

+ 4个工作周期都有**CPU访存**操作，只是访存的目的不同。取指周期是为了**取指令**，间址周期是为了**取有效地址**，执行周期是为了**取操作数**，中断周期是为了**保存程序断点**

+ 为了区别不同的工作周期，在CPU内设置4个标志触发器**FE（取指周期）、IND（间址周期）、EX（执行周期）、INT（中断周期）**，并以**1**状态表示有效，分别由**$\rm 1 \rightarrow FE, 1 \rightarrow IND, 1 \rightarrow EX, 1 \rightarrow INT$**这四个信号控制

  > 中断周期中的**进栈**操作是将**SP减1**，和传统意义上的进栈操作**相反**，原因是计算机的**堆栈**中都是向**低地址**增加，所以进栈操作是减1而不是加1

### 指令周期的数据流

+ 根据指令要求依次访问的**数据序列**。在指令执行的不同阶段，要求依次访问的数据序列是不同的，而且对于不同的指令，它们的数据流往往也是不同的。

+ `取指周期`

  + 根据**PC**中的内容从**主存**中取出指令代码并存放在**IR**中

  + **PC**存放的是**指令的地址**，根据此地址从内存单元中取出的是**指令**，并放在指令寄存器**IR**中，取指令的同时，**PC**加1

    ![image-20220621153511156](../images/image-20220621153511156.png)

  + 取指周期的数据流向如下

    + **PC**到**MAR**到**地址总线**到**主存**
    + **CU**发出控制信号到**控制总线**到**主存**
    + **主存**到**数据总线**到**MDR**到**IR**（存放指令）
    + **CU**发出读命令，**PC**内容加**1**

+ `间址周期`

  + 取**操作数**有效地址。

  + 将**指令**中的**地址码**送到**MAR**并送至**地址总线**，此后**CU**向**存储器**发读命令，以获取**有效地址**并存至**MDR**

    ![image-20220621154142989](../images/image-20220621154142989.png)

  + 间址周期的数据流向如下

    + **Ad(IR)**（或MDR）到**MAR**到**地址总线**到**主存**。

    + **CU**发出读命令到**控制总线**到**主存**

    + **主存**到**数据总线**到**MDR**（存放有效地址）

      > Ad(IR)表示取出**IR**中存放的指令字的**地址字段**

+ `执行周期`

  + 根据**IR**中的指令字的**操作码**和**操作数**通过**ALU**操作产生执行结果，不同指令的执行周期操作不同，因此没有统一的数据流向

+ `中断周期`

  + **处理中断请求**

  + 假设程序断点存入**堆栈**中，并用**SP**指示栈顶地址，而且进栈操作是先修改**栈顶指针**，后存入数据

    ![image-20220621154848023](../images/image-20220621154848023.png)

  + 中断周期的数据流向如下

    + **CU**控制将**SP**减1，**SP**到**MAR**到**地址总线**到**主存**
    + **CU**发出写命令到**控制总线**到**主存**
    + **PC**到**MAR**到**数据总线**到**主存**（程序断点存入主存）
    + **CU**（中断服务程序的入口地址）到**PC**

### 指令执行方案

+ 一个指令周期通常要包括几个时间段（执行步骤），每个步骤完成指令的一部分功能，几个依次执行的步骤完成这条指令的全部功能。出于性能和成本的考虑，可以选用3种不同的方案来安排**指令的执行步骤**
  + `单指令周期`
    + 所有指令都选用**相同的执行时间**来完成，指令之间**串行执行**
    + 指令周期取决于**执行时间最长**的指令的执行时间
  + `多指令周期`
    + 不同类型的指令选用**不同的执行步骤**来完成，指令之间**串行执行**
    + 可选用不同个数的**时钟周期**来完成不同指令的执行过程，指令需要几个周期就为其分配几个周期，不再要求所有指令占用相同的执行时间
  + `流水线方案`
    + 指令之间可以**并行执行**
    + 通过在每个**时钟周期**启动一条指令，尽量让多条指令**同时运行**，但各自处在不同的执行步骤中

## 数据通路的功能和基本结构

### 数据通路的功能

+ **数据**在**功能部件**之间传送的路径。路径上的部件称为**数据通路部件**，如**ALU、通用寄存器、状态寄存器、异常和中断处理逻辑**等。
+ 描述了**信息**从什么地方开始，中间经过哪个**寄存器**或**多路开关**，最后传送到哪个**寄存器**
+ 数据通路中，专门进行**数据运算**的部件称为**执行部件**或**功能部件**。数据通路由**控制部件**控制，控制部件根据每条指令功能的不同生成对**数据通路**的控制信号，并正确控制**指令**的执行流程
+ 实现CPU内部的**运算器**与**寄存器及寄存器之间的数据交换**

### 数据通路的基本结构

+ `CPU内部单总线方式`

  + 将所有**寄存器**的输入端和输出端都连接到**一条**公共通路上，但**数据传输**存在较多的冲突现象，性能较低
  + 连接各部件的**总线**只有一条时，称**单总线结构**，有两条或更多总线时，构成**双总线结构**或**多总线结构**

+ `CPU内部三总线方式`（**数据总线**、**控制总线**、**地址总线**）

  + 将所有**寄存器**的输入端和输出端都连接到**多条**公共通路上，提高效率

+ `专用数据通路方式`

  + 根据**指令**执行过程中的**数据**和**地址**的流动方向安排连接线路，避免使用**共享的总线**，性能较高，但硬件量大

  ![image-20220621181240466](../images/image-20220621181240466.png)

  > **内部总线**是指**同一部件**，如CPU内部连接各**寄存器**及**运算部件**之间的总线；
  >
  > **系统总线**是指同一台计算机系统的**各部件**，如CPU、内存、通道和各类I/O接口间互相连接的总线

+ `寄存器之间的数据传送`

  + 通过**CPU内部总线**完成

    + 举例**PC寄存器**，把**PC**内容送至**MAR**，流程及控制信号如下

      ```assembly
      PC -> Bus
      // PCout有效，PC内容送总线
      
      Bus -> MAR
      // MARin有效，总线内容送MAR
      ```

+ `主存与CPU之间的数据传送`

  + 通过**CPU内部总线**完成

    + 举例**CPU**从**主存**读取指令，流程及控制信号如下

      ```assembly
      PC -> Bus -> MAR
      // PCout和MARin有效，现行指令地址 -> MAR
      
      1 -> R
      // CU发读命令
      
      MEM(MAR) -> MDR
      // MDRin有效
      
      MDR -> Bus -> IR
      // MDRout和IRin有效，现行指令 -> IR
      ```

+ `执行算术或逻辑运算`

  + 由于**ALU**本身是没有内部存储功能的**组合电路**，因此如要执行加法运算，相加的两个数必须在**ALU**的两个输入端同时有效。

    + 举例上图的**暂存器**Y，先将一个**操作数**经**CPU内部总线**送入**暂存器**Y保存，Y的内容在**ALU**的左输入端始终有效，再将另一个操作数经总线直接送到**ALU**的右输入端。这样两个数就都送入了**ALU**，运算结果暂存在**暂存器**Z中

      ```assembly
      Ad(IR) -> Bus -> MAR
      // MDRout和MARin有效
      
      1 -> R
      // CU发读命令
      
      MEM -> 数据线 -> MDR
      // 操作数从存储器 -> 数据线 -> MDR
      
      MDR -> Bus -> Y
      // MDRout和Yin有效，操作数 -> Y
      
      (ACC)+(Y) -> Z
      // ACCout和ALUin有效，CU向ALU发加命令，结果 -> Z
      
      Z -> ACC
      // Zout和ACCin有效，结果 -> ACC
      ```

+ 数据通路结构直接影响CPU内各种信息的**传送路径**，数据通路不同，指令执行过程的微操作序列的安排也不同，关系着**微操作信号**形成部件的设计

## 控制器的功能和工作原理

### 控制器的结构和功能

![image-20220621194625077](../images/image-20220621194625077.png)

+ 上图主要连接关系
  + **运算器**部件通过数据总线与**内存储器**、**输入设备**和**输出设备**传送数据
  + **输入设备**和**输出设备**通过接口电路与**总线**相连接
  + **内存储器**、**输入设备**和**输出设备**从**地址总线**接收地址信息，从**控制总线**得到**控制信号**，通过**数据总线**与其他部件传送数据
  + **控制器**部件从**数据总线**接收指令信息，从**运算器**部件接收指令**转移地址**，送出**指令地址**到**地址总线**，还要向系统中的部件提供它们运行所需要的**控制信号**
+ **控制器**是计算机系统的指挥中心，主要功能有
  + 从**主存**中取出一条指令，并指出**下一条**指令在主存中的位置
  + 对指令进行**译码**或**测试**，产生相应的操作控制信号，以便启动规定的动作
  + 指挥并控制**CPU**、**主存、输入和输出设备**之间的数据流动方向

### 硬布线控制器

+ 根据指令的要求、当前时序及外部和内部的状态，按时间的顺序发送一系列**微操作控制信号**。

+ 由复杂的**组合逻辑门电路**和一些**触发器**构成，因此又称**组合逻辑控制器**

+ 硬布线控制单元图

  + 指令的**操作码**是决定控制单元发出不同操作命令（**控制信号**）的关键。为了简化**控制单元**（CU）的逻辑，将指令的**操作码**译码和**节拍发生器**从CU中分离出来，便可得到简化的控制单元图

    ![image-20220621201520187](../images/image-20220621201520187.png)

  + CU的输入信号来源如下

    + 经**指令译码器**译码产生的**指令**信息。
      + 现行指令的**操作码**决定了不同指令在执行周期所需完成的不同操作，因此指令的**操作码**字段是控制单元的**输入信号**，它与时钟配合产生不同的控制信号
    + **时序系统**产生的**机器周期信号**和**节拍信号**。
      + 为了使**控制单元**按一定的先后顺序、一定的节奏发出各个控制信号，**控制单元**必须受时钟控制，即一个时钟脉冲使**控制单元**发送一个操作命令，或发送一组需要同时执行的操作命令
    + 来自**执行单元**的反馈信息即**标志**
      + **控制单元**有时需依赖CPU当前所处的状态产生控制信号，如BAN指令，控制单元要根据上条指令的结果是否为**负**来产生不同的控制信号。

  + 上图中，**节拍发生器**产生各机器周期中的节拍信号，使不同的微操作命令$C_i$（控制信号）按时间的先后发出。个别指令的操作不仅受**操作码**控制，还受**状态标志**控制，因此**CU**的输入来自**操作码**译码电路ID、**节拍发生器**及**状态标志**，其输出到CPU内部或外部**控制总线**上。

    > 控制单元还接收来自**系统总线**（控制总线）的控制信号，如中断请求、DMA请求

+ 硬布线控制器的时序系统及微操作

  + `时钟周期`

    + 用**时钟信号**控制**节拍发生器**，可以产生节拍，每个节拍宽度正好对应一个时钟周期。在每个节拍内机器可完成一个或几个需同时执行的操作

  + `机器周期`

    + 所有指令执行过程中的一个基准时间
    + 不同指令的操作不同，指令周期也**不同**
    + **访问一次存储器**的时间是固定的，因此通常用**存取周期**作为基准时间，即**内存**中读取一个**指令字**的最短时间作为**机器周期**。
    + 在**存储字长**等于**指令字长**的前提下，**取指周期**也可视为**机器周期**
    + 在一个**机器周期**里可完成若干**微操作**，每个**微操作**都需一定的时间，可用时钟信号来控制每个**微操作**命令

  + `指令周期`

    + 详见 [指令周期](#指令周期)

  + `微操作命令分析`

    + **控制单元**具有发出各种操作命令（控制信号）序列的功能。这些命令与**指令**有关，而且必须按照一定次序发出，才能使机器有序工作。

    + 执行程序的过程中，对于不同的**指令**，**控制单元**需发出各种不同的**微操作命令**，一条指令分为**3**个工作周期：**取指周期、间址周期、执行周期**。下面分析各子周期的微操作命令

      + `取指周期`

        + PC（现行指令地址） -> MAR
        + 1 -> R，命令**存储器**读
        + M(MAR) -> MDR，现行指令从**存储器**读至**MDR**
        + MDR -> IR，现行指令 -> IR
        + OP(IR) -> CU，指令的**操作码** -> CU译码
        + (PC) + 1 -> PC，形成下一条指令的地址

      + `间址周期`（完成取**操作数**地址的任务）

        + Ad(IR) -> MAR，将指令字中的**地址码**（形式地址）-> MAR
        + 1 -> R，命令**存储器**读
        + M(MAR) -> MDR，将**有效地址**从**存储器**读至MDR

      + `执行周期`

        ![image-20220627081300597](../images/image-20220627081300597.png)

+ CPU的控制方式

  + `同步控制方式`
    + 系统有一个统一的**时钟**，所有的控制信号均来自这个统一的时钟信号
    + 通常以**最长**的微操作序列和**最繁琐**的微操作作为标准，采取完全统一的、具有相同**时间间隔**和相同**数目**的**节拍**作为**机器周期**来运行不同的指令
    + 优点是**控制电路简单**，缺点是**运行速度慢**
  + `异步控制方式`
    + 不存在**基准时标信号**，各部件按自身固有的速度工作，通过**应答方式**进行联络
    + 优点是**运行速度快**，缺点是**控制电路比较复杂**
  + `联合控制方式`
    + 对各种不同的指令的微操作实行**大部分采用同步控制、小部分采用异步控制**的办法

+ 硬布线控制单元设计步骤

  + **列出微操作命令的操作时间表**
  + **进行微操作信号综合**
  + **画出微操作命令的逻辑图**

### 微程序控制器

+ 采用**存储逻辑**实现，也就是把微操作信号代码化，使每条机器指令转化成为一段微程序并存入一个专门的**存储器（控制存储器）**中，微操作控制信号由**微指令**产生

+ 设计思想就是**将每条机器指令**编写成一个**微程序**，每个**微程序**包含若干**微指令**，每条**微指令**对应一个或几个**微操作命令**。这些**微程序**可以存到一个控制存储器中，用寻址用户程序指令的办法来寻址每个微程序的微指令。

  > 目前，大多数计算机都采用**微程序设计技术**

+ 基本术语

  + `微命令与微操作`
    + 一条机器指令可以分解成一个微操作序列，这些微操作是计算机中**最基本、不可再分解**的操作。
    + 在微程序控制的计算机中，将控制部件向执行部件发出的各种控制命令称为**微命令**，是构成控制序列的最小单位
    + 微命令是微操作的**控制信号**，微操作是微命令的**执行过程**
  + `微指令与微周期`
    + 微指令是若干微命令的集合，存放微指令的控制存储器的单元地址称为**微地址**，一条微地址通常至少包含两大部分信息
      + `操作控制字段`（**微操作码字段**）
        + 用于产生某一步操作所需的各种操作控制信号
      + `顺序控制字段`（**微地址码字段**）
        + 用于控制产生下一条将要执行的微指令地址
    + 微周期通常指从**控制存储器**中读取一条微指令并执行相应的**微操作**所需的时间
  + `主存储器与控制存储器`
    + **主存储器**用于存放**程序**和**数据**，在CPU外部，用RAM实现
    + **控制存储器（CM）**用于存放**微程序**，在CPU内部，用ROM实现
  + `程序与微程序`
    + **程序**是指令的有序集合，用于完成特定的功能
    + **微程序**是微指令的有序集合，一条指令的功能由一段微程序来实现

+ **微程序**和**程序**是两个不同的概念。微程序是由微指令组成的，用于描述**机器指令**。**微程序**实际上是机器指令的实时解释器，由计算机设计者事先编制好并存放在**控制存储器**中的，一般不提供给用户。对程序员来说，计算机系统中的**微程序**的结构和功能是**透明**的，无须知道。而**程序**最终由机器指令组成，是由软件设计人员事先编制好并存放在**主存**或**辅存**中的

+ 区分以下寄存器

  + `地址寄存器`
    + 存放**主存**的读/写地址
  + `微地址寄存器`
    + 存放**控制存储器**的读/写**微指令**的地址
  + `指令寄存器`
    + 存放从**主存**中读出的指令
  + `微指令寄存器`
    + 存放从**控制存储器**中读出的微指令

+ 微程序控制器的组成和工作过程

  + 基本组成
    + `控制存储器`
      + 微程序控制器的**核心**部件，用于存放各指令对应的**微程序**，控制存储器可用**只读存储器ROM**构成
    + `微指令寄存器`
      + 用于存放从**CM**中取出的微指令，它的位数同**微指令**字长相等
    + `微地址形成部件`
      + 用于产生**初始**微地址和**后继**微地址，以保证微指令的连续执行
    + `微地址寄存器`
      + 接收**微地址**形成部件送来的微地址，为在CM中读取微指令作准备
  + 工作过程
    + 实际上就是在**微程序控制器**的控制下，计算机执行**机器指令**的过程，可如下描述
      + 执行**取微指令**公共操作
        + 在机器开始运行时，自动将**取指**微程序的入口地址送入CMAR，并从CM中读出相应的微指令送入CMDR。取指微程序的入口地址一般为CM的0号单元，当取指微程序执行完后，从**主存**中取出的**机器指令**就已存入**指令寄存器**中。
      + 由机器指令的**操作码**字段通过微地址形成部件产生该机器指令所对应的微程序的入口地址，并送入CMAR
      + 从CM中逐条取出对应的**微指令**并执行
      + 执行完对应一条机器指令的一个**微程序**后，又回到取指微程序的入口地址，继续第1步，以完成取下一条机器指令的公共操作
  + 微程序和机器指令
    
    + 通常，一条**机器指令**对应一个**微程序**,由于任何一条机器指令的取指令操作都是相同的，因此可将取指令操作的**微命令**统一编成一个**微程序**，这个微程序只负责将**指令**从**主存**单元中取出并送至**指令寄存器**
    + 此外也可，编出对应**间址周期**的微程序和**中断周期**的微程序，这样，控制存储器中的微程序个数，应为**机器指令**数加上对应**取指**、**间址**和**中断周期**等共用的微程序数
    
    > 若指令系统中具有**n**种机器指令，则控制存储器中的微程序数至少是**n+1**（1为公共的取指微程序）
  
+ 微指令的编码方式

  + 又称微指令的**控制方式**，是指如何对微指令的**控制字段**进行编码，以形成**控制信号**。编码的目标是**保证速度的情况下，尽量缩短微指令字长**
  
  + `直接编码（直接控制方式）`
    + 直接编码法无须进行**译码**，微指令的微命令字段中，每**位**都代表一个微命令。设计微指令时，选用或不选用某个微命令，只要将表示该微命令的对应**位**设置成**1**或**0**即可。每个微命令对应并控制数据通路中的一个微操作。
    
    + 优点是**简单、直观、执行速度快、操作并行性好**，缺点是**微指令字长过长**，n个微命令就要求微指令的**操作字段**有n位，造成**控制存储器**容量极大
    
      ![image-20220628071556265](../images/image-20220628071556265.png)
    
  + `字段直接编码方式`
  
    + 将**微指令**的**微命令**字段分成若干小字段，把互斥性微命令组合在同一字段中，把相容性微命令组合在不同字段中，每个字段独立编码，每种**编码**代表一个微命令，且各字段编码含义单独定义，与其他字段无关
  
      ![image-20220628071826504](../images/image-20220628071826504.png)
  
    + 这种方式可以**缩短指令字长**，但因为要通过**译码电路**后再发出微命令，因此比**直接编码**方式慢
  
    + 微命令字段分段原则
  
      + **互斥性**微命令分在**同一段**内，**相容性**微命令分在**不同段**内
      + 每个小段中包含的信息位不能太多，否则将增加**译码线路**的复杂性和译码时间
      + 一般每个小段还要留出一个**状态**，表示本字段不发出任何微命令。
        + 因此，当某字段的长度为3位时，最多只能表示**7**个互斥的微命令，通常用**000**表示不操作
  
  + `字段间接编码方式`
  
    + 一个字段的某些**微命令**需由另一个字段中的某些**微命令**来解释，由于不是靠字段直接**译码**发出的微命令，因此称为**字段间接编码**（又称**隐式编码**）
    + 优点是**可进一步缩短微指令字长**，但因削弱了微指令的并行控制能力，因此通常作为**字段直接编码**方式的一种辅助手段
  
+ 微指令的地址形成方式

  + 两大基本类型
    + **直接由微指令的下地址字段**指出（又称**断定方式**）
      + 微指令格式中设置一个下地址字段，由微指令的**下地址**字段直接指出**后继微指令**的地址

    + **根据机器指令的操作码**形成
      + 机器指令取至**指令寄存器**后，微指令的地址由**操作码**经**微地址形成部件**形成

  + 其他类型
    + **增量计数器法**
      + 即**(CMAR) + 1 -> CMAR**，适用于后继微指令的**地址连续**的情况

    + 根据各种**标志**决定微指令分支转移的地址
    + 通过**网络测试**形成
    + 由**硬件**直接产生微程序入口地址

  + 电源加电后，第一条微指令的地址可由专门的**硬件电路**产生，也可由外部直接向**CMAR**输入微指令地址，这个地址即为**取指周期微程序**的入口地址

+ 微指令的格式

  + 与微指令的**编码方式**有关，通常分**水平型**和**垂直型**两种

    + `水平型`

      + 从**编码方式**看，**直接编码、字段直接编码、字段间接编码、混合编码**都是

      + 基本指令格式如下，指令字中的一位对应一个**控制信号**，有输出时为**1**，否则为**0**

        ![image-20220628074910014](../images/image-20220628074910014.png)

      + 优点是**微程序短，执行速度快**，缺点是**微指令长，编写微程序较麻烦**


    + `垂直型`
    
      + 特点是采用类似**机器指令操作码**的方式，在微指令中设置**微操作码字段**，采用**微操作码编译法**，由**微操作码**规定微指令的功能
    
      + 基本的指令格式如下，一条微指令只能定义并执行**一种**基本操作
    
        ![image-20220628075229615](../images/image-20220628075229615.png)
    
      + 优点是**微指令短、简单、规整、便于编写微程序**，缺点是**微程序长，执行速度慢，工作效率低**
    
    + `混合型微指令`
    
      + 在垂直型的基础上增加一些不太复杂的并行操作。微指令较短，仍便于编写；微程序也不长，执行速度加快
    
    + **水平型**微指令和**垂直型**微指令的比较如下
    
      + **水平型**微指令**并行操作能力强、效率高、灵活性强**，**垂直型**微指令则较差
      + **水平型**微指令执行一条指令的**时间短**，**垂直型**执行的时间**长**
      + **水平型**微指令解释指令的微程序，具有微指令**字较长**但**微程序短**的特点，**垂直型**则与之相反，其微指令**字短**而**微程序长**
      + **水平型**微指令用户**较难掌握**，而**垂直型**微指令与**指令**比较相似，相对**容易掌握**

+ 微程序控制单元的设计步骤

  + 写出对应**机器指令**的**微操作命令**及**节拍安排**
  + 确定**微指令**格式
    + 包括微指令的**编码方式、后继微指令地址的形成方式、微指令字长**

  + 编写**微指令**码点

+ 动态**微程序**设计和**毫微程序**设计

  + `动态微程序设计`
    + 在一台**微程序**控制的计算机中，如果能根据用户的要求**改变微程序**，则这台机器就具有**动态微程序设计**功能
    + 需要**可写控制寄存器**的支持，否则难以改变微程序的内容。可采用**可擦除可编程只读存储器（EPROM）**

  + `毫微程序设计`
    + 普通的**微程序**计算机中，从**主存**取出的每条指令是由放在**控制存储器**中的微程序来解释执行的，通过**控制线**对硬件直接控制。若硬件不由**微程序**直接控制，而是通过存放在第二级**控制存储器**的**毫微程序**来解释的，这个第二级**控制存储器**就称为**毫微存储器**，直接控制硬件的是**毫微微指令**

+ **硬布线**和**微程序控制器**的特点

  + `硬布线控制器`

    + 优点是由于控制器的速度取决于电路延迟，所以**速度快**；缺点是由于将控制部件视为专门产生固定时序控制信号的逻辑电路，所以把用最少元件和取得最高速度作为设计目标，**一旦设计完成，就不可能通过其他额外修改添加新功能**

  + `微程序控制器`

    + 优点是同组合逻辑控制器相比，微程序控制器具有**规整性、灵活性、可维护性**等一系列优点；缺点是由于微程序控制器采用了存储程序原理，所以每条指令都要从**控制存储**中取一次，**影响速度**

  + 两者的对比表格

    | 对比项目 |                         微程序控制器                         |                         硬布线控制器                         |
    | -------- | :----------------------------------------------------------: | :----------------------------------------------------------: |
    | 工作原理 | 微操作控制信号以**微程序**的形式存放在**控制存储器**中，执行指令时读出即可 | 微操作控制信号由**组合逻辑电路**根据当前的**指令码、状态、时序**即时产生 |
    | 执行速度 |                              慢                              |                              快                              |
    | 规整性   |                            较规整                            |                         烦琐、不规整                         |
    | 应用场合 |                           CISC CPU                           |                           RISC CPU                           |
    | 易扩充性 |                          易扩充修改                          |                             困难                             |


## 指令流水线

### 指令流水线的基本概念

一条指令的执行过程可分解为若干阶段，每个阶段由相应的功能部件来完成。如果将各阶段视为相应的流水线，则指令的执行过程就构成了一条**指令流水线**。采用流水线技术只需增加**少量硬件**就能把计算机的运算速度提高几倍，因此称为计算机中普遍使用的一种并行处理技术

+ 指令流水的定义

  + 根据计算机的不同，具体的分法也不同。

    + 举例如下分成三个阶段

      ![image-20220628170403952](../images/image-20220628170403952.png)

    + `取指`

      + 根据PC内容访问主存储器，取出一条指令送到IR中

    + `分析`

      + 对**指令操作码**进行**译码**，按照给定的**寻址方式**和**地址**字段中的内容形成**操作数**的**有效地址EA**，并从有效地址中取出**操作数**

    + `执行`

      + 根据**操作码**字段，完成指令规定的功能，即把运算结果写到**通用寄存器**或**主存**中

  + 当多条指令在处理器中执行时，可采用以下两种方式

    + `顺序执行方式`（**串行执行方式**）

      + 前一条指令执行完后，才启动下一条指令

        + 假设**取指、分析、执行**三个阶段的时间都相等，用**t**表示，顺序执行**n**条指令所用时间T为
          $$
          T=3nt
          $$

        + 传统**冯·诺依曼机**采用顺序执行方式

        + 优点是**控制简单，硬件代价小**；缺点是**执行指令的速度较慢**，在任何时刻，处理机中，只有一条指令在执行，各功能部件的利用率很低

          + 例如，**取指**时内存是忙碌的，而**指令执行部件**是空闲的

    + `流水线执行方式`

      + 为了提高指令的**执行速度**，可以把**取k+1**条指令提前到**分析第k条**指令的期间完成，而将**分析第k+1条**指令与**执行第k条**指令同时进行

        + 采用此种方式，执行**n**条指令所用的时间为
          $$
          T=(2+n)t
          $$

      + 与顺序执行方式相比，采用流水线执行方式能使指令的执行时间**缩短**近2/3，各功能部件的**利用率**明显提高。但**硬件**上要付出较大开销的代价，控制过程也更**复杂**。

      + 理想情况下，每个时钟周期都有一条指令进入流水线，处理机中同时有**3**条指令在执行，每个时钟周期都有**一**条指令完成，每条指令的时钟周期数（即**CPI**）都为**1**。

        ![image-20220628191439754](../images/image-20220628191439754.png)

      + 为了进一步获得更高的**执行速度**，还可以将**流水段**进一步细分。如将一条指令的执行过程分为**取指令（IF）、指令译码（ID）、（取操作数（OF））、执行（EX）、写回（WB）**四个阶段，就形成了**四级流水**（或**五级流水**）

      + 流水线设计**原则**

        + **指令流水段**个数以**最复杂**指令所用的**功能段**个数为准
        + **流水段**的长度以**最复杂**的操作所花的时间为准
          + 假设某条指令的3个阶段所花时间如下，不考虑**数据通路**中的各种延迟，该指令总执行时间为450ps，按照**流水线**设计原则，每个**流水段**的长度为200ps，所以每条指令的执行时间为600ps，反正比串行执行时增加了150ps。因此，**流水线方式并不能缩短一条指令的执行时间**，但是，对整个程序来说，可以大大增加指令执行的**吞吐率**
            + **取指**：200ps
            + **分析**：100ps
            + **执行**：150ps

      + 为了利于**实现指令流水线**，指令集应具有如下特征

        + **指令长度应尽量一致**，有利于简化**取指令**和**指令译码**操作。否则，取指令所花时间长短不一，使**取指部件**部件极其复杂，且也不利于**指令译码**
        + **指令格式应尽量规整**，尽量保证源寄存器的位置相同，有利于在指令未知时就可取**寄存器操作数**，否则须**译码**后才能确定指令中各寄存器编号的位置。
        + 采用**Load/Store**指令，其他指令（如**运算指令**）都不能访问存储器，这样可把**Load/Store**指令的**地址计算**和**运算指令的执行**步骤规整在同一个周期中，有利于减少操作步骤
        + **数据**和**指令**在存储器中“对齐”存放。这样，有利于减少访存次数，使所需数据在一个流水段内就能从存储器得到

+ 流水线的表示方法

  + 通常用**时空图**来直观地描述流水线的工作过程，**横坐标**表示**时间**，即输入流水线中的各个任务在流水线中所经过的时间。**流水线**中各个**流水段**的执行时间都相等时，横坐标就被分割成相等长度的时间段。**纵坐标**表示**空间**，即**流水线**的每个**流水段**（对应各**执行部件**）

    ![image-20220628202515351](../images/image-20220628202515351.png)

+ 流水线方式的特点

  + 与传统的串行执行方式相比，采用流水线方式具有如下特点
    + 把一个任务（一条**指令**或一个**操作**）分解为几个有联系的子任务，每个子任务由一个专门的功能部件来执行，并依靠多个功能部件**并行**工作来缩短程序的执行时间
    + 流水线每个功能段部件后面都要有一个**缓冲寄存器**，或称**锁存器**，其作用是**保存本流水段的执行结果，供给下一流水段使用**
    + 流水线中各功能段的**时间**应尽量相等，否则将引起**堵塞、断流**
    + 只有连续不断地提供**同一种**任务时，才能发挥流水线的效率，所以在流水线中处理的必须是**连续任务**。在采用流水线方式工作的处理机中，要在软件和硬件设计等多方面尽量为流水线提供**连续的任务**
    + 流水线需要有**装入时间**和**排空时间**
      + `装入时间`
        + **第一个**任务**进入**流水线到**输出**流水线的时间
      + `排空时间`
        + **最后一个**任务**进入**流水线到**输出**流水线的时间

### 流水线的分类

+ **部件功能**级、**处理机**级和**处理机间**级流水线（按**使用级别**分类）
  + `部件功能`级流水线将复杂的**算术逻辑运算**组成**流水线**工作方式
    + 将**浮点加法**操作分成**求阶差、对阶、尾数相加、结果规格化**四个子过程
  + `处理机`级流水把**一条指令**解释过程分成多个子过程
    + 如前面提到的**取指、译码、执行、访存、写回**等5个子过程
  + `处理机间`级流水是一种**宏**流水，其中每个处理机完成某一专门任务，各个处理机得到的结果需存放在与**下一个**处理机共享的存储器中
+ **单功能**流水线和**多功能**流水线（按**可以完成的功能**分类）
  + `单功能`流水线是指只能实现一种固定的专门功能的流水线
  + `多功能`流水线是指通过各段间的不同连接方式可以**同时**或**不同时**地实现多种功能的流水线
+ **动态**流水线和**静态**流水线（按**同一时间内各段之间的连接方式**分类）
  + `静态`流水线指在同一时间内，流水线的各段只能按**同一种**功能的连接方式工作
  + `动态`流水线指在同一时间内，当某些段正在实现某种运算时，另一些段却正在进行另一种运算。这样对提高流水线的效率很有好处，但会使流水线控制变得很复杂
+ **线性**流水线和**非线性**流水线（按**流水线的各个功能段之间是否有反馈信号**分类）
  + `线性`流水线中，从输入到输出，每个功能段只允许经过一次，不存在**反馈回路**。
  + `非线性`流水线存在**反馈回路**，从输入到输出的过程中，某些功能段将数次通过流水线，这种流水线适合进行**线性递归**的运算

### 影响流水线的因素

在指令流水线中，可能会遇到一些情况，使得流水线无法正确执行后续指令而引起流水线**阻塞**或**停顿**，这种现象称为**流水线冲突（冒险）**。导致流水线冲突的原因主要有3种：**资源冲突（结构冒险）、数据冲突（数据冒险）、控制冲突（控制冒险）**

+ `资源冲突`

  + 由于多条指令在**同一时刻**争用**同一资源**而形成的冲突，即由**硬件资源竞争**造成的冲突，有以下两种解决办法

    + 前一指令访存时，使后一条相关指令（以及其后续指令）暂停一个时钟周期

    + 单独设置**数据存储器**和**指令存储器**，使**取数**和**取指令**操作各自在不同的存储器中进行

      > 事实上，现在计算机都引入了**Cache**机制，而L1 Cache通常采用**数据Cache**和**指令Cache**分离的方式，因而也就避免了该冲突

+ `数据冲突`

  + 在一个程序中，下一条指令会用到当前指令计算出的结果，此时这两条指令即为**数据冲突**，当多条指令重叠处理时就会发生冲突，数据冲突可分为三类
    + `写后读`（**Read After Write， RAW**）
      + 表示当前指令将**数据**写入**寄存器**后，下一条指令才能从该寄存器读取数据。否则，**先读后写**，读到的就是**错误数据（旧数据）**
    + `读后写`（**Write After Read， WAR**）
      + 表示当前指令**读出**数据后，下一条指令才能**写**该寄存器。否则，**先写后读**，读到的就是**错误数据（新数据）**
    + `写后写`（**Write After Write，WAW**）
      + 表示当前指令**写入**寄存器后，下一条指令才能**写**该寄存器。否则，下一条指令在当前指令之前写，将使寄存器的值不是最新值
  + 解决的办法有以下几种
    + 把遇到数据相关的**指令**及其后续指令都**暂停**一至几个时钟周期，直到数据相关问题**消失**后再继续执行，可分为**硬件阻塞（stall）**和**软件插入“NOP”指令**两种方法
    + 设置相关**专用通路**，即不等前一条指令把计算结果**写**回寄存器组，下一条指令也不再**读**寄存器组，而直接把前一条指令的ALU的计算结果**作为**自己的输入数据开始计算过程，使本来需要暂停的操作变得可以继续执行，这称为**数据旁路技术**
    + 通过**编译器**对数据相关的指令编译优化的方法，调整指令顺序来解决数据相关

+ `控制冲突`

  + 一条指令要确定**下一条**指令的位置

    + 例如在执行**转移、调用、返回**等指令时会改变PC值，而造成断流，会引起**控制冒险**

  + 解决办法

    + 对**转移指令**进行分支预测，尽早生成**转移目标地址**。
      + 分支预测分为**简单（静态）预测**和**动态预测**
      + `静态预测`总是预测条件不满足，即继续执行分支指令的后续指令
      + `动态预测`根据程序执行的历史情况，进行动态预测调整，有较高的预测准确率
    + **预取**转移成功和不成功两个控制流方向上的目标指令
    + **加快和提前**形成条件码
    + **提高**转移方向的猜准率

    > Cache缺失的处理过程也会引起流水线**阻塞**，再不过多增加硬件成本的情况下，如何尽可能地**提高指令流水线的运行效率**，是选用指令流水线数必须解决的关键问题

### 流水线的性能指标

衡量流水线性能的主要指标有**吞吐率、加速比、效率**，下面以**线性流水线**为例分析，分析方法和有关公式也适用于**非线性**流水线

+ `流水线的吞吐率`

  + 在指令级流水线中，吞吐率是指在**单位时间**内流水线所完成的**任务数量**，或**输出结果的数量**。计算流水线吞吐率（TP）的最基本的公式为
    $$
    TP = \frac{n}{T_k}
    $$
    其中，**n**是任务数，**$T_k$**是处理完n个任务所用的时间

+ `流水线的加速比`

  + 完成同样一批任务，**不使用流水线**所用的时间与**使用流水线**所用的时间之比

  + 设**$T_0$**表示**不**使用流水线时的执行时间，即顺序执行所用的时间。**$T_k$**表示使用流水线时的执行时间，则计算流水线加速比（S)的基本公式为
    $$
    S=\frac{T_0}{T_k}
    $$
    若流水线各段执行的时间都相等，则一条**k**段流水线完成**n**个任务所需的时间为**$T_k=(k+n-1)\Delta t$**。而不使用流水线，即**顺序**执行n个任务时，所需的时间为**$T_0=kn\Delta t$**，将**$T_0$**和**$T_k$**的值代入上式，得实际加速比
    $$
    S=\frac{kn\Delta t}{(k+n-1)\Delta t}=\frac{kn}{k+n-1}
    $$
    连续输入的任务数$n \rightarrow \infty$ 时，最大加速比为**$S_{max}=k$** 

+ `流水线的效率`

  + 流水线的设备利用率称为**流水线的效率**

  + 在**时空图**上，流水线的效率定义为**完成n个任务占用的时空区有效面积**，与n个任务所用的**时间**及k个流水段所围成的**时间区**总面积之比。因此，流水线的效率包含了**时间**和**空间**两个因素

  + n个任务占用的时空区有效面积就是**顺序执行n个任务所使用的总时间$T_0$**，而n个任务所用的时间与k个流水段所围成的时空区总面积为$kT_k$，其中$T_k$是流水线完成n个任务所使用的总时间，因此流水线效率（E)的一般公式为
    $$
    E=\frac{n个任务占用的时空区有效面积}{n个任务所用的时间与k个流水段所围成的时空区总面积}=\frac{T_0}{kT_k}
    $$
    若流水线的各段**执行时间相等**，当连续输入的任务数$n \rightarrow \infty$ 时，最高效率为$E_{max}=1$

### 超标量流水线的基本概念

+ `超标量流水线技术`

  + 每个时钟周期可以**并发**多条独立指令，即以并行操作方式将两条或多条指令编译并执行，为此需配置多个功能部件

  + 超标量计算机不能**调整**指令的执行顺序，因此通过**编译优化**技术是，把可并行执行的指令搭配起来，挖掘更多的执行并行性

    ![image-20220629190339092](../images/image-20220629190339092.png)

+ `超流水线技术`

  + 在一个时钟周期内再**分段**，在一个时钟周期内一个功能部件使用多次

  + 不能**调整**指令的执行顺序，靠编译程序解决优化问题

    ![image-20220629190555113](../images/image-20220629190555113.png)

+ `超长指令字`

  + 由**编译程序**挖掘出指令间潜在的并行性，将多条能并行操作的指令组成一条具有多个**操作码**字段的超长指令字（可达几百位），为此需采用多个处理部件

## 总结

+ 各种字长关系
  + **指令字长**一般取**存储字长**的整数倍，若**指令字长**为**存储字长**的2倍，则需要两次访存，**取指周期**等于**机器周期**的2倍
  + **指令字长**取决于**操作码**的长度、**操作数地址**的长度和**操作数地址**的个数，与**机器字长**没有必然联系
+ **CPU**分为哪几部分？分别实现什么功能？
  + `运算器`
    + 负责数据的加工，即对数据进行**算术**和**逻辑运算**

  + `控制器`
    + 整个系统的**指挥中枢**，对整个计算机系统进行有效的控制，包括**指令控制、操作控制、时间控制、中断处理**

+ **指令**和**数据**均放在内存中，计算机如何从时间和空间上区分它们是指令还是数据？
  + `时间`
    + **取指令**时间发生在**取指周期**，**取数据**时间发生在**执行周期**

  + `空间`
    + 从**内存**读出的指令流流向**控制器**（**指令寄存器**），从**内存**读出的数据流流向**运算器**（**通用寄存器**）

+ 什么是**指令周期、机器周期、时钟周期**？它们之间有什么关系？
  + `指令周期`
    + CPU每**取出**并**执行**一条指令所需的全部时间

  + `机器周期`
    + 在同步控制的机器中，执行指令周期中一步相对完整的操作（**指令步**）所需的时间，通常安排**机器周期**长度=**主存周期**

  + `时钟周期`
    + 计算机主时钟的周期时间，它是计算机运行时**最基本**的时序单位，对应完成一个**微操作**所需的时间，通常**时钟周期**=**计算机主频**的倒数

+ 指令周期是否有一个固定值？为什么？
  + 由于计算机中各种指令执行所需的时间差异很大，因此为了提高CPU的运行效率，即使在同步控制的机器中，不同指令的指令周期长度都是**不一致**的

+ 什么是**微指令**？
  + **控制部件**通过**控制线**向执行部件发出各种控制命令，通常把这种控制命令称为**微命令**，而一组实现一定操作功能的微命令的组合，构成一条**微指令**。许多条微指令组成的序列构成**微程序**，微程序完成对**指令**的解释执行。
  + **指令**，即**机器指令**，每条指令可以完成一个独立的**算术运算**或**逻辑运算**操作，在采用**微程序控制器**的CPU中，一条指令对应一个**微程序**，一个微程序由许多**微指令**构成，一条微指令会发出很多不同的**微命令**

+ 什么是**指令流水线**？指令流水线相对于传统计算机体系结构的优势是什么？如何计算指令流水线的加速比？
  + **指令流水线**是把指令分解为若干子过程，通过将每个子过程与其他子过程**并行**执行，来提高计算机的吞吐率的技术。采用**流水线技术**只需增加少量硬件就能把计算机的运算速度提高几倍，因此成为计算机中普遍使用的一种**并行处理技术**，通过在同一个时间段使用各功能部件，使得**利用率**明显提高
  + **流水线的加速比**指的是完成同样一批任务，**不使用**流水线所用的时间与**使用**流水线所用的时间之比。一条**k**段流水线理论上的最大加速比为**$S_{max}=k$**，因此，在现代计算机中提高流水线**段**数有利于提高计算机的吞吐量。具体的加速比要使用**时空图**来计算

+ **流水线**越多，并行度就越高，是否**流水段**越多，指令执行越快？
  + **错误**
  + **流水段**缓冲之间的**额外开销**增大。每个流水段有一些额外开销用于缓冲间传送数据、进行各种准备和发送等功能，这些开销加长了一条指令的整个执行时间，当指令间逻辑上相互依赖时，开销更大
  + **流水段**间**控制逻辑**变多、变复杂。用于**流水线优化**和**存储**器（或**寄存器**）冲突处理的**控制逻辑**将随**流水段**的增大而增大，这可能导致用于流水**段之间**控制的逻辑比**段**本身的控制逻辑更复杂。

+ 有关**指令**相关、**数据**相关的几个概念
  + 两条连续的指令读取**相同**的寄存器时，会产生**读后读**（Read After Read， RAR）相关，这种相关不会影响流水线
  + 某条指令要读取上一条指令所写入的寄存器时，会产生**写后读**（Write After Read， WAR）相关，它称**数据相关**或**真相关**，影响流水线。**按序流动**的流水线只可能出现**RAW**相关
  + 某条指令的上条指令要**读/写**该指令的输出寄存器时，会产生**读后写**（Write After Read）和**写后写**（Write After Write）相关，在**非按序**流动的流水线中，既可能发生**RAW**相关，也可能发生**WAR**相关和**WAW**相关
  + 对流水线影响**最严重**的指令相关是**数据相关**


# 总线

## 总线概述

为了更好地解决**I/O设备**和**主机**之间连接的灵活性问题，计算机的结构从**分散连接**发展为**总线连接**，为了进一步简化设计，又提出了各类总线标准

### 总线基本概念

+ 总线的定义
  + 一组能为多个部件**分时共享**的公共信息传送线路。**分时**和**共享**是总线的两个特点。
  + **分时**是指同一时刻只允许有一个部件向总线发送信息，若系统中有多个部件，则它们只能分时地向总线发送信息
  + **共享**是指总线上可以挂接多个部件，各个部件之间互相交换的信息都可通过这组线路**分时共享**
  + 在某一时刻只允许有一个部件向**总线**发送消息，但多个部件可同时从**总线**上接收相同的信息
+ 总线设备
  + 按**其对总线有无控制功能**可分为**主设备**和**从设备**两种
    + `主设备`
      + 总线的主设备是指获得**总线控制权**的设备
    + `从设备`
      + 被主设备访问的设备，它只能响应从**主设备**发来的各种总线命令
+ 总线特性
  + 指**机械特性**（尺寸、形状）、**电气特性**（传输方向、有效的电平范围）、**功能特性**（每根传输线的功能）、**时间特性**（信号和时序的关系）
+ 总线的猝发传输方式
  + 在一个总线周期内传输**存储地址**连续的多个数据字的总线传输方式，称为**猝发传送**

### 总线的分类

+ 按**功能**分类

  + `片内总线`

    + **芯片**内部的总线，是**CPU**芯片内部**寄存器**与**寄存器之间**、**寄存器与ALU之间**的公共连接线

  + `系统总线`

    + 计算机系统内各功能部件（**CPU、主存、I/O接口**）之间的相互连接的总线

    + 按**系统总线传输信息内容**的不同，可分为3类

      + `数据总线`
        + 传输各功能部件之间的数据信息，是**双向**传输总线，其**位数**与**机器字长、存储字长**有关
      + `地址总线`
        + 指出**数据总线**上的源数据或目的数据所在的**主存单元**或**I/O端口**的地址，是**单向**传输总线，**地址总线**的位数与**主存**地址空间的大小有关
      + `控制总线`
        + 传输**控制信息**，包括**CPU**送出的控制命令和**主存**（或外设）返回CPU的反馈信号

      > 注意区分**数据通路**和**数据总线**：各个功能部件通过**数据总线**连接形成的**数据传输路径**，称为**数据通路**。数据通路表示的是**数据流经的路径**，而**数据总线**是承载的媒介

  + `通信总线`

    + 在**计算机系统**之间或**计算机系统与其他系统**（如远程通信设备、测试设备）之间传送信息的总线，通信总线也称**外部总线**
    + 按**时序控制方式**可将总线划分为**同步总线**和**异步总线**，还可按**数据传输格式**将总线划分为**并行**总线和**串行**总线

### 系统总线的结构

+ 通常分为**单总线结构、双总线结构、三总线结构**

  + `单总线结构`

    + 将**CPU、主存、I/O设备（通过I/O接口）**都挂在一组总线上，允许**I/O设备**之间、**I/O设备与主存**之间直接交换信息，而无须经过中间设备的干预

      > 单总线并不是指只有一根信号线，系统总线按**传送信息**的不同可细分为**地址总线、数据总线、控制总线**

    + 优点是**结构简单，成本低，易于接入新的设备**。缺点是**带宽低、负载重，多个部件只能争用唯一的总线，且不支持并发传送操作**

      ![image-20220630180446051](../images/image-20220630180446051.png)

  + `双总线结构`

    + `主存总线`

      + 用于在**CPU、主存、通道**之间传送数据

    + `I/O总线`

      + 在多个**外部设备与通道**之间传送数据

    + 优点是**将低速I/O设备从单总线上分离出来，实现了存储器总线和I/O总线分离**。缺点是**需要增加通道等硬件设备**

      ![image-20220630180434353](../images/image-20220630180434353.png)

  + `三总线结构`

    + `主存总线`
      + 用于在**CPU、内存**之间传送**地址、数据、控制**信息
    + `I/O总线`
      + 在**CPU、各类外设**之间通信
    + `DMA总线`（**直接内存访问总线**）
      + 在**内存、高速外设**之间直接传送数据
    + 优点是**提高了I/O设备的性能，使其更快地响应命令，提高系统吞吐量**。缺点是**系统工作效率较低**

### 总线的性能指标

+ `总线的传输周期`

  + 一次总线操作所需的时间（包括**申请、寻址、传输、结束**阶段），简称**总线周期**。通常由若干**总线时钟周期**构成

+ `总线时钟周期`

  + 即**机器的时钟周期**。计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制

+ `总线的工作频率`

  + 总线上各种操作的频率，为**总线周期**的倒数。实际上指1秒内传送几次数据。若**总线周期=N个时钟周期**，则总线的**工作频率=时钟频率/N**

+ `总线的时钟频率`

  + 即**机器的时钟频率**，为**时钟周期**的倒数

+ `总线宽度`（**总线位宽**）

  + 总线上同时能够传输的数据位数，通常指**数据总线**的根数
    + 如32根称为32位总线。

+ `总线带宽`

  + 总线的**数据传输率**，即单位时间内总线上可传输数据的位数，通常用**每秒传送信息的字节数**来衡量，单位可用**字节/秒**（B/s）表示。

    > 总线带宽 = 总线工作频率 * （总线宽度 / 8），应与**总线宽度**区分开来

+ `总线复用`

  + 一种信号线在不同的**时间**传输不同的信息，因此可以使 用较少的线传输更多的信息，从而节省空间和成本

+ `信号线数`

  + **地址总线、数据总线、控制总线**3种总线数的总和

  + 总线最主要性能指标为**总线宽度、总线（工作）频率、总线带宽**

    + **总线带宽**是指总线本身所能达到的**最高传输效率**，是衡量总线性能的重要指标

      > 总线带宽 = 总线宽度 * 总线频率

## ~~总线仲裁~~

## 总线操作和定时

+ **总线定时**
  + 总线在双方交换数据的过程中，需要**时间**上配合关系的控制
  + 实质是一种**协议**或**规则**，主要有**同步、异步**两种基本定时方式

### 总线传输的4个阶段

+ 一个总线周期通常可分为以下4个阶段
  + `申请分配阶段`
    + 由需要使用总线的**主模块**（或主设备）提出申请，经**总线仲裁机构**决定将**下一传输周期**的总线使用权授予某一申请者。也可将此阶段细分为**传输请求**和**总线仲裁**两个阶段
  + `寻址阶段`
    + 取得使用权的**主模块**通过总线发出本次要访问的**从模块**（或从设备）的地址及有关命令，启动参与本次传输的**从模块**
  + `传输阶段`
    + **主模块**和**从模块**进行数据交换，可**单向**或**双向**进行数据传送
  + `结束阶段`
    + **主模块**的有关信息均从**系统总线**上撤除，让出总线使用权

### 同步定时方式

+ 系统采用一个**统一的时钟信号**来协调**发送**和**接收**双方的传送定时关系。
+ 时钟产生相等的时间间隔，每个间隔构成一个**总线周期**
+ 在一个**总线周期**中，发送方和接收方可以进行一次数据传送
+ 因为采用**统一的时钟**，每个部件或设备发送或接收信息都在固定的**总线传送周期**中，一个总线的传送周期结束，下一个总线的传送周期开始
+ 优点是**传送速度快，具有较高的传输速率；总线控制逻辑简单**。缺点是**主从设备属于强制性同步；不能及时进行数据通信的有效性检验，可靠性较差**
+ **同步通信**适用于**总线长度较短**及**总线所接部件的存取时间比较接近**的系统

### 异步定时方式

+ 没有**统一的时钟**，也没有**固定的时间间隔**，完全靠传送双方相互制约的**握手**信号来实现**定时控制**。

+ 优点是**总线周期长度可变，能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换，自动适应时间的配合**，缺点是**比同步控制方式稍复杂一点，速度比同步定时方式慢**

+ 根据**请求**和**回答**信号的**撤销**是否**互锁**，异步定时方式又分为以下3种类型

  + `不互锁方式`

    + **主设备**发出请求信号后，不必**等到**接到**从设备**的回答信号，而是经过一段时间便**撤销**请求信号。而**从设备**在接到请求信号后，发出回答信号，并经过一段时间后自动**撤销**回答信号。

  + `半互锁方式`

    + **主设备**发出请求信号后，**必须**在接到**从设备**的回答信号后，才**撤销**请求信号。而**从设备**在接到请求信号后，发出回答信号，但不必**等待**获知**主设备**的请求信号已经**撤销**，而是隔一段时间后自动**撤销**回答信号

  + `全互锁方式`

    + **主设备**发出请求信号后，必须在**从设备**回答后才**撤销**请求信号；**从设备**发出回答信号后，必须在获知**主设备**请求信号已**撤销**后，再**撤销**其回答信号

    ![image-20220705083606283](../images/image-20220705083606283.png)

## 总线标准

## 总结

# 输入/输出系统

## I/O系统基本概念

## 外部设备

## I/O接口

## I/O方式

## 总结

