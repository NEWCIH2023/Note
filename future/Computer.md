
+ 计算机系统概述
	+ 计算机发展历程
	+ 计算机系统层次结构
		+ 计算机硬件的基本组成
			+ 输入设备
			+ 输出设备
			+ 存储器
				+ MAR (Memory Address Register) 地址寄存器 - **存放访存地址，经过地址译码后找到所选的存储单元，用于寻址**
				+ MDR (Memory Data Register) 数据寄存器
			+ 运算器
				+ ALU (Arithmetic And Logical Unit) 算术逻辑单元 - **运算器的核心**
				+ ACC (Accumulator) 累加器
				+ MQ (Multiple-Quotient Register) 乘商寄存器
				+ X 操作数寄存器
				+ IX 变址寄存器
				+ BR 基址寄存器
				+ PSW 程序状态寄存器/标志寄存器
			+ 控制器
				+ PC (Program Counter) 程序计数器 - **存放当前欲执行指令的地址，可以自动加1以形成下一条指令的地址**
				+ IR (Instruction Register) 指令寄存器 - **存放当前的指令，数据来自主存的MDR**
				+ CU (Control unit) 控制单元

	+ 计算机的性能指标
		+ 主要性能指标
			+ 运算速度
				+ 主频和CPU时钟周期
					+ CPU时钟周期。即**主频的倒数**，是**CPU中最小的时间单位**，执行指令的每个动作至少需要1个时钟周期
					+ CPU时钟周期 = 1 / CPU主频
					+ 主频通常以**Hz**为单位，1Hz表示每秒1次。
				+ CPI (Clock cycle Per Instruction)
					+ 执行一条指令所需的时钟周期数
					+ 不同指令的时钟周期数可能不同，对一个程序或机器来说，其CPI指该程序或该机器指令集中所有的指令执行所需的平均时钟周期数，此时**CPI是一个平均值**
				+ CPU执行时间
					+ `CPU执行时间 = CPU时钟周期数 * CPU时钟周期 = CPU时钟周期数 / 主频 = (指令条数 * CPI) / 主频 = (指令条数 * CPI) * CPU时钟周期`
				+ MIPS (Million Instructions Per Second)
					+ 每秒执行多少百万条指令
					+ MIPS = 指令条数 / (执行时间 * 10^6) = 主频 / (CPI * 10^6)
				+ MFLOPS (Mega Floating-point Operations Per Second)
				+ GFLOPS (Giga Floating-point Operations Per Second)
				+ TFLOPS (Tera Floating-point Operations Per Second)
			+ 主存容量
				+ 以`字节`衡量，也可用`字数 * 字长`，如`512K * 16`来表示
				+ MAR的位数，表示 **存储单元的个数**，MDR的位数，表示 **可寻址范围的最大值**
				+ MAR为16位，表示 2^16 = 65536，即有65536个存储单元（可称为64K内存），若MDR为32位，表示存储容量为 **64K * 32位**
	+ 总结
		+ MDR, MAR虽然是存储器的一部分，但在现代CPU中，却是存在于CPU中，与高速缓存(Cache)一样
		+ 在描述存储容量、文件大小等时，K、M、G、T通常用2的幂次表示，如1Kb = 2^10b；在描述速率、频率等时，k、M、G、T通常用10的幂次表示，如 1kb/s = 10^3 b/s。通常前者用大写的K，后者用小写的k，但其他前缀均为大写，表示的含义取决于所用的场景。
		+ 翻译程序：把高级语言源程序翻译成机器语言程序（目标代码）的软件。有两种
			+ 编译程序：将高级语言源程序一次全部翻译成目标程序，每次执行程序时，只需执行目标程序。
			+ 解释型程序：将源程序的一条语句翻译成对应的机器目标代码，并立即执行，然后翻译下一条源程序语句并执行，直至所有源程序语句全部被翻译并执行完。（不会生成目标程序）
		+ 汇编程序也是一种语言翻译程序，把汇编语言源程序翻译为机器语言程序。
		+ 编译程序与汇编程序的区别：若源程序是 **C，C++，Java** 等高级语言，而目标语言是 **汇编语言，或机器语言** 之类的低级语言，则称这样的翻译程序为编译程序。若源语言是 **汇编语言**，而目标语言是 **机器语言**，则这样的翻译程序称为 **汇编程序**。
		+ 在计算机领域，站在某类用户的角度，若感觉不到某个事物或属性的存在，即“看”不到某个事物或属性，则称为“对该用户透明”。与日常生活中的“透明”概念正好相反。
		+ 在CPU中，IR，MAR和MDR对各类程序员都是透明的
		+ 机器字长 VS 指令字长 VS 存储字长
			+ 机器字长：计算机能直接处理的二进制数据的位数，机器字长一般等于内部寄存器的大小，它决定了计算机的运算精度。
			+ 指令字长：一个指令字中包含的二进制代码的位数。
			+ 存储字长：一个存储单元存储的二进制代码的长度。
			+ 指令字长一般取存储字长的整数倍，若指令字长等于存储字长的2倍，则需要2次访存来取出一条指令。

+ 数据的表示和运算
	+ 数制与编码
		+ 真值：带“+”或“-”符号的数称为真值
		+ 机器数：把符号“数字化”的数称为机器数
		+ 0 ~ 9 的ASCII码值为 **48 （011 0000） ~ 57 （011 1001）**，即去掉高3位，只保留低4位，正好是二进制形式的 0~9
		+ BCD (Binary-Coded Decimal) 二进制编码的10进制数
		+ 7E5H，H代表16进制
		+ 进制转换
			+ 二进制转八进制、十六进制
				+ 以小数点为界，将一串二进制数分为3位一组或4位一组。整数部分，从左边开始补0，小数部分，从右边开始补0。
			+ 八进制、十六进制转二进制
				+ 只需将每位改为3位或4位二进制数即可
			+ 任意进制转十进制
				+ 保底法：如果存在小数部分，则根据二进制、八进制、十六进制，乘以对应的基数，每乘一次，就左移一位，直到全部是整数。这时候就通过位置法计算出十进制，然后再除以之前乘的数
				+ 将任意进制数的各位数码与它们的权值相乘，再把乘积相加，就得到了一个十进制数。这种方法称为按权展开相加法。
					+ (11011.1) = 1\*2^4 + 1\*2^3 + 0\*2^2 + 1\*2^1 + 1\*2^0 + 1\*2^-1 = 27.5
			+ 十进制转任意进制
				+ 整数部分用除基取余法，小数部分用乘基取整法，最后将整数部分和小数部分的转换结果拼接起来
				+ 除基取余法：**整数部分除基取余，最先取得的余数为数的最低位，最后取得的余数为数的最高位（即除基取余，先余为低，后余为高），`商为0` 时结束。
				+ 乘基取整法：**小数部分(乘基后如果出现整数部分，则整数部分不参与下一次乘基计算)乘基取整，最先取得的整数为数的最高位，最后取得的整数为数的最低位（即乘基取整，先整为高，后整为低），乘积为1.0（或满足精度要求）时结束。
				+ ![image-20220517164713443](../images/image-20220517164713443.png)
		+ 校验码
			+ 奇偶校验码
				+ 实现方法：由若干位有效信息，再加上一个二进制位（校验位）组成校验码。校验码的取值（0或1）将使整个校验码中“1”的个数为奇数或偶数。
				+ 奇校验码：整个校验码（有效信息位和校验位）中“1”的个数为奇数
				+ 偶校验码：整个校验码（有效信息位和校验位）中“1”的个数为偶数
			+ 海明校验码 (Hamming Code，也称 **汉明码**，多重奇偶校验码，具有纠错能力)
				+ 实现方法：在有效信息位中加入几个校验位形成海明码，并把海明码的每个二进制位分配到几个奇偶校验组中。当某一位出错后，就会引起有关的几个校验位的值发生变化，这不但可以发现错位，还能指出错位的位置，为自动纠错提供依据。
				+ ** L(编码最小码距) - 1 = D(检测错误的位数) + C(纠正错误的位数) 且 D >= C **
				+ 编码最小码距L越大，其检测错误的位数D越大，纠正错误的位数C也越大，且纠错能力恒小于等于检错能力。
		
	+ 定点数的表示与运算
		+ 真值零的原码表示有 **正零** 和 **负零** 两种形式
		+ 移位运算
			+ 有符号位的称 **算术移位**，**逻辑移位**的操作对象是逻辑代码，可视为无符号数。
			+ 算术移位的空位添补规则
	
			||码制|添补代码|
			|:---:|:---:|:--:|
			|正数|原码、补码、反码|0|
			|负数|原码|0|
			|负数|补码|左移添0，右移添1|
			|负数|反码|1|
	
			> 分析由原码得到补码的过程发现，当对其由低位向高位找到第一个“1”时，在此“1”左边的各位均与对应的反码相同，而在此“1”右边的各位（包括此“1”在内）均与对应的原码相同。因此负数的补码左移时，因空位出现在低位，则添补的代码与原码相同，即添0；右移时因空位出现在高位，则添补的代码应与反码相同，即添1。
			
			+ 逻辑移位
				左移，高位移丢，低位补0；右移，低位移丢，高位补0
			+ 循环移位
				循环移位操作特别适合将数据的低字节数据和高字节数据互换
	
		+ 符号扩展
			+ 有时必须把采用给定位数表示的数转换成具有不同位数的某种表示形式。--如将一个8位数与一个32位数相加，要想得到正确的结果，必须先将8位数转换成32位数的形式
			+ 正数的符号扩展：原有形式的符号位移动到新形式的符号位上，新表示形式的所有附加位都用0进行填充。
			+ 负数的符号扩展
				+ 原码表示法：与正数相同，符号位为1
				+ 补码表示法：用1（对于整数）或0（对于小数）填充，符号位为1
				+ 反码表示法：用1填充，符号位为1
		+ 原码，反码，补码，移码
			+ 在计算机系统中，数值一律用补码来表示和存储。原因在于，使用补码，可以将符号位和数值域统一处理；同时，加法和减法也可以统一处理。
			
			+ 反码不能直接用来做运算，其结果要+1才能正常（结果是-0，也要+1，让其变为+0，这才是正确结果）
			
			+ 补码做运算时，正负符号参与运算
			
			+ 补码 = 反码 + 1，因此原码与反码均有两个0表示法，而补码只有一个，原先-0表示的，现在称为补码多出来的一个负数表示
			
			+ 移码 = 补码的符号位取反
			
			+ 移码常用来 **比较大小**，一般会把浮点数的阶码用移码表示，说的再通俗一点，把数值用移码表示出来可以一看看出他们的大小，这样很容易判断阶码的大小，移码可以 **简化浮点数的乘除法运算** 
			
			+ 原码一位乘法
				+ 由手写竖式乘法发展而来
				+ 被乘数和乘数均取绝对值参与运算，符号位为 X 异或 Y
				+ 部分积的长度同被乘数，取 **n + 1**位，以便存放乘法过程中绝对值大于等于1的值，初值为0.
				+ 从乘数的最低位y开始判断：若y=1，则部分积加上被乘数|x|，然后右移一位；若y=0，则部分积加上0，然后右移一位。
				+ 重复上一个步骤，判断n次
				+ 由于乘积的数值部分是两数绝对值相乘的结果，因此原码一位乘法运算过程中的右移操作均为逻辑右移
				+ 考虑到运算时可能出现绝对值大于1的情况（但此刻并非溢出），所以部分积和被乘数取双符号位
				
			+ 溢出概念和判别方法
				+ 溢出：运算结果超过了数的表示范围。大于机器所能表示的最大正数为上溢，小于机器所能表示的最小负数为下溢。
				+ 补码定点数加减运算溢出判断
					+ 一位符号位
						+ 参加操作的两个数符号相同，结果又与原操作数符号不同，则表示结果溢出
						+ 若符号位的进位Cs与最高数位的进位C1相同，则说明没有溢出，否则发生溢出。
					+ 双符号位 (**模4补码**)
						+ 运算结果的两个符号位S1，S2相同，表示未溢出；运算结果的两个符号位S1，S2不同，表示溢出，此时最高位符号位代表真正的符号。
						+ S1，S2 = 00：结果正数，无溢出
						+ S1，S2 = 01：结果正溢出
						+ S1，S2 = 10：结果负溢出
						+ S1，S2 = 11：结果负数，无溢出
			
			+ 整数类型及类型转换
				+ 不同字长整数之间的转换
					+ 当大字长变量向小字长变量强制类型转换时，系统把多余的高位字长部分直接截断，低位直接赋值，因此也是一种保持位值的处理方法。
					+ 短字长整数到长字长整数的转换，不仅要使相应的位值相等，高位部分还会扩展为原数字的符号位。
				+ 有符号数和无符号数的转换
					```c
						int main() {
							short x = -4321;
							unsigned short y = (unsigned short) x;
							printf("x = %d, y=%u\n", x, y);
						}
					```
					对比两者的二进制表示
			
					|变量|值|位|位|位|位|位|位|位|位|位|位|位|位|位|位|位|
					|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|:--:|
					|||15|14|13|12|11|10|9|8|7|6|5|4|3|2|1|
					|x|-4321|1|1|1|0|1|1|1|1|0|0|0|1|1|1|1|1|
					|y|61215|1|1|1|0|1|1|1|1|0|0|0|1|1|1|1|1|
			
					可知，将 **short int** 强制转换为 **unsigned short** 只改变数值，而两个变量对应的每位都是一样的。即强制类型转换的结果保持位值不变，仅改变了解释这些位的方式。
				
			+ 数据存储的 **大端方式** VS **小端方式**
				+ 大端方式：按从最高有效字节到最低有效字节的顺序存储数据，即最高有效字节存放在前面
				+ 小端方式：按从最低有效字节到最高有效字节的顺序存储数据，即最低有效字节存放在前面
				
			+ 数据按 **边界对齐** 方式存储
				+ 对于机器字长为32位的计算机，数据以边界对齐方式存放，半字地址一定是2的整数倍，字地址一定是4的整数倍。所存储的数据不满足上述要求时，通过填充空白字节使其符合要求。这样无论所取的数据是字节、半字还是字，均可一次访存取出，提高取指令和取数的速度。
				+ 边界对齐是一种空间换时间的思想。RISC如 **ARM** 采用边界对齐，而CISC如 **x86** 对齐和不对齐都支持，因为对齐方式取指令时间相同，因此能适应指令流水。
		
	+ 浮点数的表示与运算
		
		+ **阶码** 控制 **小数点的位置**，**阶码每加一，整个数值增大到2倍，小数点向右移一位**，**阶码每减一，整个数值减少2倍，小数点向左移一位**
		
		+ 15张图带你了解浮点数
		
		  ![图片](../images/640-16531029311641.png)
		
		  ![图片](../images/640-16531029754623.png)
		
		  ![图片](../images/640-16531030031665.png)
		
		  **注意上图中，阶码应该是 01111100，图片有误，但结果无误，移码表示法的01111100，其真值为-4，但是IEEE754规定，阶码E采用 `指数e的移码-1`来表示，即01111011，其真值为-3**
		
		  ![图片](../images/640-16531032479427.png)
		
		  ![图片](../images/640-16531033307209.png)
		
		  ![图片](../images/640-165310338687211.png)
		
		  ![图片](../images/640-165310353210413.png)
		
		  ![图片](../images/640-165310355806915.png)
		
		  ![图片](../images/640-165310356633717.png)
		
		+ 浮点数的一般格式
		
		  ![image-20220521102345388](../images/image-20220521102345388.png)
		
		  ![image-20220521102406922](../images/image-20220521102406922.png)
		
		+ 规格化浮点数
		
		  通过调整一个 **非规格化浮点数** 的 **尾数和阶码** 的大小，使非零的浮点数在 **尾数的最高数位上保证是一个有效值**。
		
		  + **左规**：当浮点数运算的结果为非规格化时，要进行规格化处理，**将尾数算术左移一位、阶码减一（基数为2时）** 的方法。 **可能要进行多次**。
		  + **右规**：当浮点数运算的结果 **尾数出现溢出（双符号位为01或10）时，将尾数算术右移一位、阶码加一（基数为2时）** 的方法。 **需要右规时，只需进行一次**。
		
		+ IEEE 754 标准
		
		  ![image-20220521105658175](../images/image-20220521105658175.png)
		
		  
		
		  > IEEE 754标准与普通浮点数格式要求要区分开。
		
		  **IEEE 754标准的浮点数（除临时浮点数外），是尾数用采取隐藏位策略的原码表示，且阶码用移码表示的浮点数。**
		
		  以短浮点数为例，最高位为 **数符位**；其后是 **8位阶码**，以 **2** 为底（**即基数为2**），用 **移码** 表示，阶码的 **偏置值** 为 2^(8-1) - 1 = 127；其后 **23** 位是原码表示的 **尾数数值位**。对于 **规格化** 的二进制浮点数，数值的最高位总是 **1**，为了能使 **尾数多表示一位有效位，将这个“1”隐含，因此尾数数值实际上是24位。隐含的“1”是一位整数。在浮点格式中表示的23位尾数是纯小数**。例如，（12）的十进制 = （1100）的二进制，将它规格化后结果为 1.1 * 2^3，其中 **整数部分的“1”将不会存储在23位尾数内**。
		
		  + IEEE 754 浮点数格式
		
		    | 类型                           | 数符 | 阶码 | 尾数数值 | 总位数 | （16进制）偏置值 | （10进制）偏置值 |
		    | ------------------------------ | :--: | :--: | :------: | :----: | :--------------: | ---------------- |
		    | 短浮点数（**单精度，float**）  |  1   |  8   |    23    |   32   |       7FH        | 127              |
		    | 长浮点数（**双精度，double**） |  1   |  11  |    52    |   64   |       3FFH       | 1023             |
		    | 临时浮点数                     |  1   |  15  |    64    |   80   |      3FFFH       | 16383            |
		
		  + IEEE 754 浮点数范围
		
		    ![image-20220521110915260](../images/image-20220521110915260.png)
		
		+ 定点 VS 浮点
		
		  + 数值的表示范围
		
		    字长相同，**浮点** 所能表示的数值范围将远远大于 **定点**
		
		  + 精度
		
		    一个数所含有效数值位的位数。对于字长相同的定点数和浮点数来说，浮点数 **扩大了数的表示范围，但降低了精度**
		
		  + 数的运算
		
		    浮点数包括 **阶码** 和 **尾数** 两部分，运算时要同时做两部分的运算，而且要求运算结果 **规格化**，所以浮点运算更复杂
		
		  + 溢出问题
		
		    定点运算，结果 **超出数的表示范围** 时，发生溢出；
		
		    浮点运算，结果 **超出数的表示范围却不一定溢出，只有规格化阶码超出所能表示的范围** 时，才发生溢出。
		  
		+ 偏置值
		
		  以单精度浮点型float为例，指数e由 **8位二进制原码（无符号）** 表示，但这样的小数不能表示 **（-1,1）** 中的数，因为阶码总是 **正数**。所以不如 **减去一个偏置量127**，这样就能表示负的 **E** （如果没有偏置，那么 **e=E**），此时 **E=e-127**，而e的范围是 **（1，254）**，最终 **阶码E的范围为 （-126,127）**。
		
	+ 算术逻辑单元（ALU）
	
	  + **运算器** 由 **算术逻辑单元（Arithmetic Logic Unit， ALU）**、**累加器**、**状态寄存器** 和 **通用寄存器** 等组成。**ALU** 的基本功能包括 **加、减、乘、除** 四则运算，**与、或、非、异或** 等逻辑运算，以及 **移位、求补** 等操作。
	
	  + **运算器** 的操作和操作种类由 **控制器** 决定。**运算器** 处理的数据来自 **存储器**；处理后的结果数据通常送回 存储器，或暂存在 **运算器** 中。
	
	  + **ALU** 的核心部件是 **加法器**，**加法器** = **全加器** + **其他必要的逻辑电路**。全加器 **单个或多个**， 决定加法器的 **串行和并行**。
	
	  + 一位全加器
	
	    + 输入
	      $$
	      加数 A_i、加数B_i、低位传来的进位C_{i-1}
	      $$
	
	    + 输出
	      $$
	      本位和S_i，向高位的进位C_i
	      $$
	
	    + 和表达式
	      $$
	      S_i = A_i \oplus B_i \oplus	C_{i-1}
	      $$
	
	    + 进位表达式
	      $$
	      C_i = A_iB_i +(A_i \oplus	B_i)C_{i-1}
	      $$
	      
	
	+ 总结
	  + 字 VS 字节 VS 位
	  	+ 1位 = 1比特
	  	+ 1字节 = 8位
	  	+ **1字 = 2字节 （一般情况下）**
	  	+ **1字 = 16位 （在1字 = 2字节的情况下，即常说的字长几位）**
	  	
	  + 码距：同一编码中，任意两个合法编码之间不同二进制数位数的最小值 (通过改变几位，使其变成另一个合法码字的最小改变量就是码距)，码距大于等于2的数据校验码开始具有检错能力。码距越大，检错、纠错能力越强。奇偶校验码的码距等于2，可以检测出一位错误，但不能确定出错位置。海明码的码距大于2，因此不仅可以发现错误，还能指出错误的位置。
	
	  + 常用二进制：
	    $$
	    2^4=16，
	    2^6=64，
	    2^{8}=256，
	    2^{16}=65536，
	    2^{32}=4294967296，
	    $$
	
	  + 校验位的计算公式，其中 **n是信息位的位数**，**k是校验位的位数**
	    $$
	    2^k - 1 >= n + k
	    $$
	
	  + **奇偶校验码不能纠错**，**CRC码可以发现并纠正信息串行读/写、存储或传送中出现的一位或多位错（与多项式的选取有关）**，**海明码能发现两位错误并纠正1位错**。
	
	  + CRC通常用于计算机网络的数据链路层，适合对大量数据的数据校验
	
	  + 并不是每个十进制小数都可以准确的用二进制表示。例如0.3。但任意一个二进制小数都可以用十进制小数表示。
	
	  + 关于十进制数转换为任意进制数为何采用除基取余法和乘基取整法，以及所取之数放置位置的原理，请结合R进制数的数值表示公式思考，而不应死记硬背。
	
+ 存储系统
	+ 存储器概述
	+ 存储器的层次化结构
	+ 半导体随机存储器
	+ 主存储器与CPU的连接
	+ 双端口RAM和多模块存储器
	+ 高速缓冲存储器
	+ 虚拟存储器
	+ 总结
	
+ 指令系统
	+ 指令格式
	+ 指令的寻址方式
	+ CISC和RISC的基本概念
	+ 总结
	
+ 中央处理器
	+ CPU的功能和基本结构
	+ 指令执行过程
	+ 数据通路的功能和基本结构
	+ 控制器的功能和工作原理
	+ 指令流水线
	+ 总结
	
+ 总线
	+ 总线概述
	+ 总线仲裁
	+ 总线操作和定时
	+ 总线标准
	+ 总结
	
+ 输入/输出系统
	+ I/O系统基本概念
	+ 外部设备
	+ I/O接口
	+ I/O方式
	+ 总结




​	

