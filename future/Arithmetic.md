
+ 绪论
	+ 数据结构的基本概念
	+ 算法和算法评价
	
+ 线性表
	+ 线性表的定义和基本操作
	+ 线性表的顺序表示
	+ 线性表的链式表示
	
+ 栈和队列

  ![截屏2022-05-24 22.35.59](../images/%E6%88%AA%E5%B1%8F2022-05-24%2022.35.59.png)
  
  
    + 栈
      + **只允许在一端进行插入或删除** 操作的 **线性表**
      
      + **卡特兰数**：$n个不同元素进栈，出栈元素不同排列的个数为\frac{1}{n+1} C^n_{2n}$
      
      + 基本操作
        ```c
        // 初始化一个空栈
        InitStack(&S)
          
        // 判断一个栈是否为空，若栈S为空则返回true，否则返回false
        StackEmpty(S)
          
        // 进栈，若栈S未满，则将x加入使之成为新栈顶
        Push(&S, x)
          
        // 出栈，若栈S非空，则弹出栈顶元素，并用x返回
        Pop(&S, &x)
          
        // 读栈顶元素，若栈S非空，则用x返回栈顶元素
        GetTop(S, &x)
          
        // 销毁栈，并释放栈S占用的存储空间
        DestroyStack(&S)
        ```
      
        > 解答算法题时，若题干未做出限制，则可直接使用这些基本的操作函数
        
      + 栈的顺序存储结构
      
        + 顺序栈
      
          一组地址连续的存储单元存放自**栈底到栈顶**的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。
      
          ```c
          // 定义栈中元素的最大个数
          #define MaxSize 50
          typedef struct {
              // 存放栈中元素
              Elemtype data[MaxSize];
              // 栈顶指针
              int top;
          } SqStack;
          ```
      
          初始时，设置 **S.top = -1**，栈顶元素 **S.data[S.top]**
      
          **进栈**：栈不满时，栈顶指针先加1，再送值到栈顶元素
      
          **出栈**：栈非空时，先取栈顶元素值，再将栈顶指针减1
      
          **栈空条件**：**S.top == -1**
      
          **栈满条件**：**S.top == MaxSize - 1**
      
          **栈长**：**S.top+1**
      
        + 共享栈
      
          利用**栈底位置相对不变**的特性，可让两个**顺序栈**共享一个一维数组空间，将两个 **栈的栈底** 分别设置在共享空间的两端，两个 **栈顶** 向共享空间的中间延伸。
      
          top0=-1时，0号栈为空，top1=MaxSize时，1号栈为空。仅当两个栈顶指针相邻时（**top1-top0==1**），判断栈满。
      
      + 栈的链式存储
      
        + 通常采用 **单链表** 实现，并规定所有操作都是在 **单链表** 的 **表头** 进行。规定**链栈没有头结点**。
      
          ```c
          typedef struct Linknode {
              // 数据域
              ElemType data;
              // 指针域
              struct Linknode *next;
          } *LiStack;  // 栈类型定义
          ```
      
      + 出栈序列判断
      
        + **在原序列中，相对位置比它小的，必须是逆序**
        + **在原序列中，相对位置比它大的，顺序没有要求**
        + **以上两点可以穿插进行**
  


  + 队列
  + 栈和队列的应用
  + 特殊矩阵的压缩存储

// TODO


+ 串
  + 串的定义和实现
  + 串的模式匹配
+ 树与二叉树
  + 树的基本概念
  + 二叉树的概念
  + 二叉树的遍历和线索二叉树
  + 树、森林
  + 树与二叉树的应用
+ 图
  + 图的基本概念
  + 图的存储及基本操作
  + 图的遍历
  + 图的应用
+ 查找
  + 查找的基本概念
  + 顺序查找和折半查找
  + B树和B+树
  + 散列表
+ 排序
  + 排序的基本概念
  + 插入排序
  + 交换排序
  + 选择排序
  + 归并排序和基数排序
  + 各种内部排序算法的比较及应用
  + 外部排序

