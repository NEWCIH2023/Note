[TOC]



# 绪论

## 数据结构的基本概念
## 算法和算法评价

# 线性表
## 线性表的定义和基本操作
## 线性表的顺序表示
## 线性表的链式表示

# 栈和队列

![截屏2022-05-24 22.35.59](../images/%E6%88%AA%E5%B1%8F2022-05-24%2022.35.59.png)


## 栈
+ **只允许在一端进行插入或删除** 操作的 **线性表**
+ **卡特兰数**：n个不同元素进栈，出栈元素不同排列的个数为**$\frac{1}{n+1} C^n_{2n}$**

### 基本操作

```c
// 初始化一个空栈
InitStack(&S)
          
// 判断一个栈是否为空，若栈S为空则返回true，否则返回false
StackEmpty(S)
          
// 进栈，若栈S未满，则将x加入使之成为新栈顶
Push(&S, x)
          
// 出栈，若栈S非空，则弹出栈顶元素，并用x返回
Pop(&S, &x)
          
// 读栈顶元素，若栈S非空，则用x返回栈顶元素
GetTop(S, &x)
          
// 销毁栈，并释放栈S占用的存储空间
DestroyStack(&S)
```

> 解答算法题时，若题干未做出限制，则可直接使用这些基本的操作函数


### 栈的顺序存储结构

+ 顺序栈

  一组地址连续的存储单元存放自**栈底到栈顶**的数据元素，同时附设一个指针（top）指示当前栈顶元素的位置。 

```c
// 定义栈中元素的最大个数
#define MaxSize 50
typedef struct {
	// 存放栈中元素
	Elemtype data[MaxSize];
	// 栈顶指针
	int top;
} SqStack;
```

初始时，设置 **S.top = -1**，栈顶元素 **S.data[S.top]**

**进栈**：栈不满时，栈顶指针先加1，再送值到栈顶元素
**出栈**：栈非空时，先取栈顶元素值，再将栈顶指针减1
**栈空条件**：**S.top == -1**

**栈满条件**：**S.top == MaxSize - 1**
**栈长**：**S.top+1**

+ 共享栈
  + 利用**栈底位置相对不变**的特性，可让两个**顺序栈**共享一个一维数组空间，将两个 **栈的栈底** 分别设置在共享空间的两端，两个 **栈顶** 向共享空间的中间延伸。
  + top0=-1时，0号栈为空，top1=MaxSize时，1号栈为空。仅当两个栈顶指针相邻时（**top1-top0==1**），判断栈满。

### 栈的链式存储

+ 通常采用 **单链表** 实现，并规定所有操作都是在 **单链表** 的 **表头** 进行。规定**链栈没有头结点**。    
```c
typedef struct Linknode {
	// 数据域
	ElemType data;
	// 指针域
	struct Linknode *next;
} *LiStack;  // 栈类型定义
```

+ 出栈序列判断
	+ **在原序列中，相对位置比它小的，必须是逆序**
	+ **在原序列中，相对位置比它大的，顺序没有要求**
	+ **以上两点可以穿插进行**

## 队列

操作受限的线性表。只允许在**表的一端进行插入**，在**表的另一端进行删除**。

**队头**：允许删除的一端，又称 **队首**

**队尾**：允许插入的一端


### 队列常见的基本操作
+ **InitQueue(&Q)**：初始化队列，构造一个空队列
+ **QueueEmpty(Q)**：判队列空，若队列Q为空返回true，否则返回false
+ **EnQueue(&Q, x)**：入队，若队列Q未满，将x加入，使之成为新的队尾
+ **DeQueue(&Q, &x)**：出队，若队列Q非空，删除队头元素，并用x返回
+ **GetHead(Q, &x)**：读队头元素，若队列Q非空，则将队头元素赋值给x

> 栈和队列是操作受限的线性表，因此不是任何线性表的操作都可以作为栈和队列的操作。比如，不可以随便读取栈或队列中间的某个数据。

### 队列的顺序存储结构


+ 队列的顺序存储
	队列的顺序实现是指**分配一块连续的存储单元存放队列中的元素，并附设两个指针：队头指针front指向队头元素，队尾指针rear指向队尾元素的下一个位置（不同教材的定义不同）**。

    ```c
    #define MaxSize 50
    typedef struct {
          ElemType data[MaxSize];
          int front, rear;
    } SqQueue;
    ```

    **初始状态（队空条件）**：Q.front == Q.rear == 0

    **进队操作**：队不满时，先送值到队尾元素，再将队尾指针加1。

    **出队操作**：队不空时，先取队头元素值，再将队头指针加1。

    > 如果出队之后，不及时移动元素到队头位置，即固定队头位置，则可能出现假溢出，也就是队尾指针等于MaxSize，但实际上还有空余位置。如下

    ![截屏2022-05-27 21.33.03](../images/%E6%88%AA%E5%B1%8F2022-05-27%2021.33.03.png)

+ 循环队列

    解决上面顺序存储队列的问题。将顺序队列 **臆造** 为一个环状的空间，即把存储队列元素的表，从 **逻辑上** 视为一个环。当队首指针 **Q.front = MaxSize - 1**后，再前进一个位置就自动到0，这可以利用**除法取余**运算实现。

    **初始时：Q.front = Q.rear = 0**

    **队首指针进1:  Q.front = （Q.front + 1）% MaxSize**

    **队尾指针进1:  Q.rear = （Q.rear + 1）% MaxSize**

    **队列长度：（Q.rear + MaxSize - Q.front）% MaxSize**

    出队入队时：指针都按顺时针方向进1，如下图

    ![截屏2022-05-27 21.43.08](../images/%E6%88%AA%E5%B1%8F2022-05-27%2021.43.08.png)

### 队列的链式存储结构

+ 队列的链式存储

    **链队列**，实际上是一个同时带有**队头指针**和**队尾指针**的单链表。**头指针指向队头结点**，**尾指针指向队尾结点**，即**单链表的最后一个结点**（注意与顺序存储的不同）

    队列的链式存储类型可描述为

    ```c
    // 链式队列结点
    typedef struct {
          ElemType data;
          struct LinkNode *next;
    } LinkNode;
        
    // 链式队列
    typedef struct {
          LinkNode *front, *rear;
    } LinkQueue;
    ```

    当**Q.front == NULL** 且 **Q.rear == NULL** 时，队列为空。

    >不带头结点的链式队列，在操作上，往往比较麻烦。因此通常设计成，带头结点的单链表。这样 插入 和 删除 就统一了。

    用单链表表示的链式队列特别适合于数据元素变动比较大的情况，而且不存在队列满且产生溢出的问题。另外，假如程序中要使用多个队列，与多个栈的情形一样，最好使用链式队列，这样就不会出现存储分配不合理和溢出问题。

### 双端队列
+ 指两端都可以进行**入队**和**出队**操作的队列。如图，其元素的**逻辑结构**还是**线性结构**。

![](../images/%E6%88%AA%E5%B1%8F2022-05-28%2010.31.08.png)

+ 输出受限的双端队列：允许在一端进行插入和删除，但在另一端只允许插入的双端队列
	
+ 输入受限的双端队列：允许在一端进行插入和删除，但在另一端只允许删除的双端队列
	
> 若限定双端队列从某个端点插入的元素只能从该端点删除，则该双端队列就蜕变为两个栈底相邻接的栈。

+ **解对应的题目时，根据输入受限，或者输出受限，对着给定选项，从里面开始，模拟左边进，右边进。左边出，右边出。**

## 栈和队列的应用


### 栈在括号匹配中的应用
### 栈在表达式求值中的应用
+ 表达式求值，中缀表达式->后缀表达式 **重要**

### 栈在递归中的应用

+ 递归模型不能是**循环定义**的
	+ 递归表达式（递归体）
	+ 边界条件（递归出口）
+ 递归算法转换为非递归算法，通常需要**栈**来实现
### 队列在层次遍历中的应用
### 队列在计算机系统中的应用
+ 解决主机与外部设备之间速度不匹配的问题
+ 解决由多用户引起的资源竞争问题

## 特殊矩阵的压缩存储

### 数组的定义

+ 每个数据元素称为一个**数据元素**，每个元素在**n**个线性关系中的序号称为该元素的**下标**，下标的取值范围称为**数组的维界**
+ **数组**与**线性表**的关系
  + **数组**是**线性表**的推广，一维数组可视为一个**线性表**；二维数组可视为其元素也是**定长线性表**的**线性表**
  + 数组一旦被定义，其**维数**和**维界**就不再改变
    + 除结构的初始化和销毁外，数组只会有**存取、修改**元素的操作

### 数组的存储结构




# 串
## 串的定义和实现
## 串的模式匹配
# 树与二叉树
## 树的基本概念
## 二叉树的概念
## 二叉树的遍历和线索二叉树
## 树、森林
## 树与二叉树的应用
# 图
## 图的基本概念
## 图的存储及基本操作
## 图的遍历
## 图的应用
# 查找
## 查找的基本概念
## 顺序查找和折半查找
## B树和B+树
## 散列表
# 排序
## 排序的基本概念
## 插入排序
## 交换排序
## 选择排序
## 归并排序和基数排序
## 各种内部排序算法的比较及应用
## 外部排序

